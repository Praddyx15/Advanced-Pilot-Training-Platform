/**
 * Aviation Training Document Management System
 * 
 * A comprehensive system for processing aviation training documents,
 * extracting content, identifying compliance procedures, and generating
 * training materials including session plans and assessment forms.
 * 
 * This system includes:
 * - Backend API (Node.js/Express)
 * - Document processing utilities
 * - Session plan generation
 * - Training form generation
 * - Frontend UI (React)
 * - MongoDB data persistence
 */

// =====================================================================
// BACKEND IMPLEMENTATION
// =====================================================================

// ----- Server Setup and Configuration -----

const express = require('express');
const multer = require('multer');
const mongoose = require('mongoose');
const cors = require('cors');
const path = require('path');
const fs = require('fs');
const { Worker } = require('worker_threads');
const pdfjs = require('pdfjs-dist');
const mammoth = require('mammoth');
const { v4: uuidv4 } = require('uuid');

// Initialize Express app
const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// Configure file upload with multer
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(__dirname, 'uploads');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueFilename = `${Date.now()}-${file.originalname}`;
    cb(null, uniqueFilename);
  }
});

const fileFilter = (req, file, cb) => {
  // Accept PDF and DOCX files
  if (file.mimetype === 'application/pdf' ||
      file.mimetype === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only PDF and DOCX files are allowed.'), false);
  }
};

const upload = multer({ 
  storage,
  fileFilter,
  limits: { fileSize: 50 * 1024 * 1024 } // 50MB file size limit
});

// MongoDB connection
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/aviation-training', {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
.then(() => console.log('MongoDB connected'))
.catch(err => console.error('MongoDB connection error:', err));

// ----- MongoDB Models -----

// Document Schema
const documentSchema = new mongoose.Schema({
  originalFilename: String,
  storedFilename: String,
  filePath: String,
  fileType: String,
  uploadDate: { type: Date, default: Date.now },
  processingStatus: {
    type: String,
    enum: ['pending', 'processing', 'completed', 'failed'],
    default: 'pending'
  },
  processingProgress: {
    stage: String,
    percent: Number,
    message: String
  },
  metadata: {
    title: String,
    author: String,
    company: String,
    publishDate: String,
    version: String,
    totalPages: Number,
    documentType: String
  },
  extractedContent: {
    sections: [Object],
    toc: [Object],
    keyTerms: [Object],
    complianceProcedures: [Object]
  }
});

const Document = mongoose.model('Document', documentSchema);

// Session Plan Schema
const sessionPlanSchema = new mongoose.Schema({
  documentId: { type: mongoose.Schema.Types.ObjectId, ref: 'Document' },
  planType: { type: String, enum: ['instructor', 'student'] },
  title: String,
  description: String,
  duration: Number,
  targetAudience: String,
  learningObjectives: [String],
  activities: [{
    title: String,
    type: String,
    description: String,
    duration: Number,
    materials: [String],
    instructorNotes: String,
    contentReferences: [String]
  }],
  materials: [{
    title: String,
    type: String,
    description: String,
    source: String,
    required: Boolean
  }],
  assessments: [{
    title: String,
    type: String,
    description: String,
    duration: Number,
    passingScore: Number
  }],
  complianceCoverage: [{
    procedureId: String,
    title: String,
    covered: Boolean,
    assessmentId: String
  }],
  creationDate: { type: Date, default: Date.now },
  lastModified: { type: Date, default: Date.now }
});

const SessionPlan = mongoose.model('SessionPlan', sessionPlanSchema);

// Training Form Schema
const trainingFormSchema = new mongoose.Schema({
  documentId: { type: mongoose.Schema.Types.ObjectId, ref: 'Document' },
  title: String,
  description: String,
  sectionReferences: [String],
  questions: [{
    type: String,
    question: String,
    options: [String],
    correctAnswer: mongoose.Schema.Types.Mixed,
    points: Number,
    complianceReference: String,
    explanation: String
  }],
  practicalTasks: [{
    description: String,
    criteria: [String],
    passingThreshold: Number,
    timeAllotted: Number,
    equipmentNeeded: [String]
  }],
  signoffRequirements: [{
    title: String,
    role: String,
    description: String,
    regulatoryReference: String
  }],
  creationDate: { type: Date, default: Date.now },
  lastModified: { type: Date, default: Date.now }
});

const TrainingForm = mongoose.model('TrainingForm', trainingFormSchema);

// ----- API Routes -----

// Upload a document
app.post('/api/documents/upload', upload.single('document'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    const newDocument = new Document({
      originalFilename: req.file.originalname,
      storedFilename: req.file.filename,
      filePath: req.file.path,
      fileType: req.file.mimetype,
      processingStatus: 'pending'
    });

    await newDocument.save();

    // Start background processing
    startDocumentProcessing(newDocument._id);

    res.status(201).json({
      message: 'Document uploaded successfully',
      documentId: newDocument._id,
      status: 'pending'
    });
  } catch (error) {
    console.error('Error uploading document:', error);
    res.status(500).json({ error: 'Failed to upload document' });
  }
});

// Get all documents
app.get('/api/documents', async (req, res) => {
  try {
    const documents = await Document.find(
      {}, 
      'originalFilename uploadDate processingStatus metadata.title metadata.totalPages'
    );
    res.json(documents);
  } catch (error) {
    console.error('Error fetching documents:', error);
    res.status(500).json({ error: 'Failed to fetch documents' });
  }
});

// Get document by ID
app.get('/api/documents/:id', async (req, res) => {
  try {
    const document = await Document.findById(req.params.id);
    if (!document) {
      return res.status(404).json({ error: 'Document not found' });
    }
    res.json(document);
  } catch (error) {
    console.error('Error fetching document:', error);
    res.status(500).json({ error: 'Failed to fetch document' });
  }
});

// Get document processing status
app.get('/api/documents/:id/status', async (req, res) => {
  try {
    const document = await Document.findById(
      req.params.id,
      'processingStatus processingProgress'
    );
    
    if (!document) {
      return res.status(404).json({ error: 'Document not found' });
    }
    
    res.json({
      status: document.processingStatus,
      progress: document.processingProgress
    });
  } catch (error) {
    console.error('Error fetching document status:', error);
    res.status(500).json({ error: 'Failed to fetch document status' });
  }
});

// Generate session plans for a document
app.post('/api/documents/:id/session-plans', async (req, res) => {
  try {
    const document = await Document.findById(req.params.id);
    if (!document) {
      return res.status(404).json({ error: 'Document not found' });
    }
    
    if (document.processingStatus !== 'completed') {
      return res.status(400).json({ 
        error: 'Document processing not completed',
        status: document.processingStatus
      });
    }
    
    const options = req.body.options || {};
    
    // Start session plan generation in background
    startSessionPlanGeneration(document._id, options);
    
    res.json({
      message: 'Session plan generation started',
      documentId: document._id
    });
  } catch (error) {
    console.error('Error generating session plans:', error);
    res.status(500).json({ error: 'Failed to generate session plans' });
  }
});

// Get session plans for a document
app.get('/api/documents/:id/session-plans', async (req, res) => {
  try {
    const sessionPlans = await SessionPlan.find({ documentId: req.params.id });
    res.json(sessionPlans);
  } catch (error) {
    console.error('Error fetching session plans:', error);
    res.status(500).json({ error: 'Failed to fetch session plans' });
  }
});

// Update a session plan
app.put('/api/session-plans/:id', async (req, res) => {
  try {
    const updates = req.body;
    updates.lastModified = Date.now();
    
    const sessionPlan = await SessionPlan.findByIdAndUpdate(
      req.params.id,
      updates,
      { new: true }
    );
    
    if (!sessionPlan) {
      return res.status(404).json({ error: 'Session plan not found' });
    }
    
    res.json(sessionPlan);
  } catch (error) {
    console.error('Error updating session plan:', error);
    res.status(500).json({ error: 'Failed to update session plan' });
  }
});

// Generate training forms for a document
app.post('/api/documents/:id/training-forms', async (req, res) => {
  try {
    const document = await Document.findById(req.params.id);
    if (!document) {
      return res.status(404).json({ error: 'Document not found' });
    }
    
    if (document.processingStatus !== 'completed') {
      return res.status(400).json({ 
        error: 'Document processing not completed',
        status: document.processingStatus
      });
    }
    
    const options = req.body.options || {};
    
    // Start training form generation in background
    startTrainingFormGeneration(document._id, options);
    
    res.json({
      message: 'Training form generation started',
      documentId: document._id
    });
  } catch (error) {
    console.error('Error generating training forms:', error);
    res.status(500).json({ error: 'Failed to generate training forms' });
  }
});

// Get training forms for a document
app.get('/api/documents/:id/training-forms', async (req, res) => {
  try {
    const trainingForms = await TrainingForm.find({ documentId: req.params.id });
    res.json(trainingForms);
  } catch (error) {
    console.error('Error fetching training forms:', error);
    res.status(500).json({ error: 'Failed to fetch training forms' });
  }
});

// Update a training form
app.put('/api/training-forms/:id', async (req, res) => {
  try {
    const updates = req.body;
    updates.lastModified = Date.now();
    
    const trainingForm = await TrainingForm.findByIdAndUpdate(
      req.params.id,
      updates,
      { new: true }
    );
    
    if (!trainingForm) {
      return res.status(404).json({ error: 'Training form not found' });
    }
    
    res.json(trainingForm);
  } catch (error) {
    console.error('Error updating training form:', error);
    res.status(500).json({ error: 'Failed to update training form' });
  }
});

// Export session plan to DOCX
app.get('/api/session-plans/:id/export', async (req, res) => {
  try {
    const sessionPlan = await SessionPlan.findById(req.params.id);
    if (!sessionPlan) {
      return res.status(404).json({ error: 'Session plan not found' });
    }
    
    // Export logic handled by DocumentSessionPlanner would go here
    // For now, we'll return a placeholder response
    
    res.json({
      message: 'Export feature is not fully implemented in this demo',
      sessionPlan: sessionPlan._id
    });
  } catch (error) {
    console.error('Error exporting session plan:', error);
    res.status(500).json({ error: 'Failed to export session plan' });
  }
});

// Export training form to DOCX
app.get('/api/training-forms/:id/export', async (req, res) => {
  try {
    const trainingForm = await TrainingForm.findById(req.params.id);
    if (!trainingForm) {
      return res.status(404).json({ error: 'Training form not found' });
    }
    
    // Export logic handled by DocumentSessionPlanner would go here
    // For now, we'll return a placeholder response
    
    res.json({
      message: 'Export feature is not fully implemented in this demo',
      trainingForm: trainingForm._id
    });
  } catch (error) {
    console.error('Error exporting training form:', error);
    res.status(500).json({ error: 'Failed to export training form' });
  }
});

// Start the server
if (process.env.NODE_ENV !== 'test') {
  app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
  });
}

// ----- Background Processing -----

/**
 * Start document processing in a background worker
 * @param {string} documentId MongoDB ID of the document to process
 */
function startDocumentProcessing(documentId) {
  // In a production environment, this would use a dedicated worker thread or job queue
  // For simplicity, we'll use a setTimeout to simulate background processing
  
  setTimeout(async () => {
    try {
      // Update document status to processing
      await Document.findByIdAndUpdate(documentId, {
        processingStatus: 'processing',
        processingProgress: {
          stage: 'extraction',
          percent: 0,
          message: 'Starting document processing'
        }
      });
      
      // Get document from database
      const document = await Document.findById(documentId);
      if (!document) {
        console.error('Document not found for processing:', documentId);
        return;
      }
      
      // Create document processor
      const processor = new DocumentProcessor();
      
      // Process the document
      const result = await processor.processDocument(document.filePath, {
        // Add event listener for progress updates
        onProgress: async (stage, percent, message) => {
          await Document.findByIdAndUpdate(documentId, {
            processingProgress: { stage, percent, message }
          });
        }
      });
      
      // Update document with extracted content
      await Document.findByIdAndUpdate(documentId, {
        processingStatus: 'completed',
        processingProgress: {
          stage: 'complete',
          percent: 100,
          message: 'Document processing completed'
        },
        metadata: result.metadata,
        extractedContent: {
          sections: result.sections,
          toc: result.toc,
          keyTerms: result.keyTerms,
          complianceProcedures: result.complianceProcedures
        }
      });
      
      console.log(`Document processing completed for document ${documentId}`);
    } catch (error) {
      console.error('Error processing document:', error);
      
      // Update document status to failed
      await Document.findByIdAndUpdate(documentId, {
        processingStatus: 'failed',
        processingProgress: {
          stage: 'error',
          percent: 0,
          message: `Processing failed: ${error.message}`
        }
      });
    }
  }, 100);
}

/**
 * Start session plan generation in a background process
 * @param {string} documentId MongoDB ID of the document
 * @param {Object} options Session plan generation options
 */
function startSessionPlanGeneration(documentId, options) {
  setTimeout(async () => {
    try {
      // Get document from database
      const document = await Document.findById(documentId);
      if (!document) {
        console.error('Document not found for session plan generation:', documentId);
        return;
      }
      
      // Create session plan generator
      const generator = new SessionPlanGenerator();
      
      // Generate session plans
      const sessionPlans = await generator.generateSessionPlans(
        document.extractedContent,
        options
      );
      
      // Save instructor and student session plans
      for (const plan of sessionPlans) {
        const sessionPlan = new SessionPlan({
          documentId,
          ...plan
        });
        await sessionPlan.save();
      }
      
      console.log(`Session plans generated for document ${documentId}`);
    } catch (error) {
      console.error('Error generating session plans:', error);
    }
  }, 100);
}

/**
 * Start training form generation in a background process
 * @param {string} documentId MongoDB ID of the document
 * @param {Object} options Training form generation options
 */
function startTrainingFormGeneration(documentId, options) {
  setTimeout(async () => {
    try {
      // Get document from database
      const document = await Document.findById(documentId);
      if (!document) {
        console.error('Document not found for training form generation:', documentId);
        return;
      }
      
      // Create training form generator
      const generator = new TrainingFormGenerator();
      
      // Generate training forms
      const forms = await generator.generateTrainingForms(
        document.extractedContent,
        options
      );
      
      // Save training forms
      for (const form of forms) {
        const trainingForm = new TrainingForm({
          documentId,
          ...form
        });
        await trainingForm.save();
      }
      
      console.log(`Training forms generated for document ${documentId}`);
    } catch (error) {
      console.error('Error generating training forms:', error);
    }
  }, 100);
}

// =====================================================================
// DOCUMENT PROCESSOR
// =====================================================================

/**
 * ProcessingOptions interface defines options for document processing
 * @typedef {Object} ProcessingOptions
 * @property {boolean} extractHeadings - Whether to extract headings from the document
 * @property {boolean} identifyCompliance - Whether to identify compliance content
 * @property {boolean} identifyKeyTerms - Whether to extract key terms
 * @property {boolean} generateAssessments - Whether to generate assessment questions
 * @property {number} sessionDuration - Target duration for training sessions (minutes)
 * @property {number} maxSessionCount - Maximum number of sessions to generate
 * @property {boolean} includeImages - Whether to include images from the document
 * @property {Array<string>} complianceRegulations - Array of regulatory references to focus on
 * @property {'basic'|'advanced'} languageProcessingLevel - Level of language processing
 * @property {'manual'|'procedures'|'training'|'regulatory'} documentType - Type of document
 * @property {'classroom'|'simulator'|'online'|'blended'} sessionFormat - Format of training sessions
 * @property {'beginner'|'intermediate'|'advanced'} studentLevel - Student experience level
 */

/**
 * DocumentProcessor class handles the extraction and analysis of content
 * from training documents (PDF, DOCX, etc.)
 */
class DocumentProcessor {
  /**
   * Create a new DocumentProcessor
   */
  constructor() {
    // Patterns for identifying key phrases in text
    this.keyPhrasePatterns = [
      /must|shall|required|mandatory|always|never/i,
      /safety|warning|caution|danger|critical/i,
      /check|verify|ensure|confirm|validate/i,
      /procedure|process|step|instruction|guideline/i,
      /comply|compliance|regulation|regulatory|rule|law/i
    ];
    
    this.compliancePhrasePatterns = [
      /in accordance with|as required by|as specified in|as per|according to/i,
      /regulation|regulatory|compliance|comply|conformance|conform to/i,
      /certification|certified|approve|approval|authorize|authorized by/i,
      /FAA|EASA|CAA|ICAO|FAR|JAR|Part \d+/i,
      /required|mandatory|shall|must|will|should/i
    ];
    
    this.safetyPhrasePatterns = [
      /warning|caution|danger|alert|attention/i,
      /safety critical|life threatening|emergency|hazard|risk/i,
      /prohibited|prevent|avoid|never|death|injury|damage/i,
      /limitation|limit|maximum|minimum|threshold|tolerance/i,
      /failure|malfunction|inoperative|fault|error/i
    ];
  }
  
  /**
   * Process a document and extract structured content
   * @param {string} filePath Path to the document file
   * @param {Object} options Processing options and callbacks
   * @returns {Promise<Object>} Extracted structured content
   */
  async processDocument(filePath, options = {}) {
    try {
      const onProgress = options.onProgress || (() => {});
      
      // Report progress
      onProgress('extraction', 0, 'Preparing to process document');
      
      // Determine file type and extract content
      const fileExt = path.extname(filePath).toLowerCase();
      let content = '';
      let metadata = null;
      
      if (fileExt === '.pdf') {
        onProgress('extraction', 10, 'Processing PDF document');
        const result = await this.extractFromPDF(filePath);
        content = result.content;
        metadata = result.metadata;
      } else if (fileExt === '.docx') {
        onProgress('extraction', 10, 'Processing Word document');
        const result = await this.extractFromDOCX(filePath);
        content = result.content;
        metadata = result.metadata;
      } else {
        throw new Error(`Unsupported file type: ${fileExt}`);
      }
      
      onProgress('extraction', 30, 'Document content extracted, analyzing structure');
      
      // Extract sections, TOC, and other structured content
      const extractedContent = await this.analyzeDocumentStructure(content, metadata);
      
      onProgress('analysis', 50, 'Identifying key terms and compliance procedures');
      
      // Extract key terms and definitions
      extractedContent.keyTerms = await this.extractKeyTerms(content, extractedContent.sections);
      
      // Identify compliance procedures
      extractedContent.complianceProcedures = await this.identifyComplianceProcedures(
        extractedContent.sections
      );
      
      onProgress('analysis', 90, 'Content analysis completed');
      
      onProgress('analysis', 100, 'Document processing complete');
      
      return extractedContent;
    } catch (error) {
      console.error('Error processing document:', error);
      throw error;
    }
  }
  
  /**
   * Extract text content from a PDF file
   * @param {string} filePath Path to the PDF file
   * @returns {Promise<{content: string, metadata: Object}>} Extracted text and metadata
   */
  async extractFromPDF(filePath) {
    try {
      // Load PDF as array buffer
      const data = fs.readFileSync(filePath);
      const pdf = await pdfjs.getDocument({ data }).promise;
      
      // Initialize metadata
      const metadata = {
        title: path.basename(filePath, '.pdf'),
        totalPages: pdf.numPages
      };
      
      // Extract PDF metadata if available
      const metadataObj = await pdf.getMetadata();
      if (metadataObj && metadataObj.info) {
        const info = metadataObj.info;
        metadata.title = info.Title || metadata.title;
        metadata.author = info.Author;
        metadata.publishDate = info.CreationDate 
          ? this.formatPdfDate(info.CreationDate)
          : undefined;
        metadata.lastModified = info.ModDate
          ? this.formatPdfDate(info.ModDate)
          : undefined;
      }
      
      // Extract text from each page
      let fullText = '';
      
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        
        // Format page content with page markers
        const pageText = content.items
          .map(item => item.str)
          .join(' ');
        
        fullText += `\n[PAGE ${i}]\n${pageText}\n[/PAGE ${i}]\n`;
      }
      
      // Clean up the extracted text
      fullText = this.cleanExtractedText(fullText);
      
      return { content: fullText, metadata };
    } catch (error) {
      console.error('Error extracting PDF content:', error);
      throw new Error('Failed to extract content from PDF');
    }
  }
  
  /**
   * Extract text content from a DOCX file
   * @param {string} filePath Path to the DOCX file
   * @returns {Promise<{content: string, metadata: Object}>} Extracted text and metadata
   */
  async extractFromDOCX(filePath) {
    try {
      // Read DOCX file
      const data = fs.readFileSync(filePath);
      
      // Use mammoth to extract content
      const result = await mammoth.extractRawText({
        buffer: data
      });
      
      // Initialize metadata
      const metadata = {
        title: path.basename(filePath, '.docx'),
        totalPages: 1 // Mammoth doesn't provide page count
      };
      
      const text = result.value;
      
      // Count approximate pages (rough estimate: ~3000 chars per page)
      const estimatedPages = Math.max(1, Math.ceil(text.length / 3000));
      metadata.totalPages = estimatedPages;
      
      // Add page markers
      let fullText = '';
      const roughPageSize = Math.ceil(text.length / estimatedPages);
      
      for (let i = 0; i < estimatedPages; i++) {
        const startIndex = i * roughPageSize;
        const endIndex = Math.min(startIndex + roughPageSize, text.length);
        const pageText = text.substring(startIndex, endIndex);
        
        fullText += `\n[PAGE ${i + 1}]\n${pageText}\n[/PAGE ${i + 1}]\n`;
      }
      
      // Clean up the extracted text
      fullText = this.cleanExtractedText(fullText);
      
      return { content: fullText, metadata };
    } catch (error) {
      console.error('Error extracting DOCX content:', error);
      throw new Error('Failed to extract content from DOCX');
    }
  }
  
  /**
   * Clean up extracted text by normalizing whitespace and fixing common issues
   * @param {string} text Raw extracted text
   * @returns {string} Cleaned text
   */
  cleanExtractedText(text) {
    // Remove excessive whitespace
    let cleaned = text.replace(/\s+/g, ' ');
    
    // Fix common OCR issues
    cleaned = cleaned.replace(/([a-z])\.([A-Z])/g, '$1. $2'); // Add space after period
    cleaned = cleaned.replace(/([a-z]),([a-z])/g, '$1, $2'); // Add space after comma
    
    // Normalize paragraph breaks
    cleaned = cleaned.replace(/\n{3,}/g, '\n\n'); // Replace 3+ newlines with 2
    
    // Remove headers and footers (often contains page numbers, dates)
    const headerFooterPattern = /^.*(?:Page \d+|^\d+).*$|^.*(?:header|footer).*$/igm;
    cleaned = cleaned.replace(headerFooterPattern, '');
    
    return cleaned;
  }
  
  /**
   * Format a PDF date string into a readable date
   * @param {string} pdfDate PDF date string (e.g., "D:20200101121212+00'00'")
   * @returns {string} Formatted date string
   */
  formatPdfDate(pdfDate) {
    if (!pdfDate || !pdfDate.startsWith('D:')) {
      return undefined;
    }
    
    try {
      // PDF date format: D:YYYYMMDDHHmmSSOHH'mm'
      // where O is the offset direction (+ or -)
      const year = pdfDate.substring(2, 6);
      const month = pdfDate.substring(6, 8);
      const day = pdfDate.substring(8, 10);
      
      return `${year}-${month}-${day}`;
    } catch (error) {
      console.error('Error formatting PDF date:', error);
      return undefined;
    }
  }
  
  /**
   * Analyze document structure and extract sections, TOC, etc.
   * @param {string} content Document text content
   * @param {Object} metadata Document metadata
   * @returns {Promise<Object>} Structured content extraction
   */
  async analyzeDocumentStructure(content, metadata) {
    try {
      // Extract table of contents if available
      const toc = this.extractTableOfContents(content);
      
      // Identify section boundaries
      const sections = this.extractSections(content, toc);
      
      // Estimate reading time for each section
      this.estimateSectionTimes(sections);
      
      // Identify compliance and safety-critical content
      this.identifyComplianceContent(sections);
      
      // Create basic metadata if not provided
      if (!metadata) {
        metadata = {
          title: this.extractDocumentTitle(content) || 'Untitled Document',
          totalPages: this.countPages(content)
        };
      }
      
      return {
        metadata,
        sections,
        toc,
        keyTerms: [], // Will be populated later
        complianceProcedures: [] // Will be populated later
      };
    } catch (error) {
      console.error('Error analyzing document structure:', error);
      throw new Error('Failed to analyze document structure');
    }
  }
  
  /**
   * Extract the title from document content
   * @param {string} content Document content
   * @returns {string|null} Extracted title or null if not found
   */
  extractDocumentTitle(content) {
    // Look for title in first page
    const firstPageMatch = content.match(/\[PAGE 1\]([\s\S]*?)\[\/PAGE 1\]/);
    if (!firstPageMatch) return null;
    
    const firstPage = firstPageMatch[1];
    
    // Look for patterns that might indicate a title
    const titlePatterns = [
      // Large text at the beginning of document
      /^\s*([A-Z][A-Z\s]{5,}[A-Z])\s*$/m,
      // Text followed by "manual", "guide", "handbook", etc.
      /^\s*(.+?(?:\s+(?:Manual|Guide|Handbook|Procedures|Training|Document)))\s*$/m,
      // Any capitalized line near the beginning
      /^\s*([A-Z][\w\s]{10,})\s*$/m
    ];
    
    for (const pattern of titlePatterns) {
      const match = firstPage.match(pattern);
      if (match && match[1]) {
        return match[1].trim();
      }
    }
    
    // If no title pattern found, use first non-empty line
    const firstLineMatch = firstPage.match(/^\s*(.{10,})/);
    if (firstLineMatch && firstLineMatch[1]) {
      return firstLineMatch[1].trim();
    }
    
    return null;
  }
  
  /**
   * Count the number of pages in document content
   * @param {string} content Document content
   * @returns {number} Number of pages
   */
  countPages(content) {
    const pageMarkers = content.match(/\[PAGE \d+\]/g);
    return pageMarkers ? pageMarkers.length : 1;
  }
  
  /**
   * Get the page number for a specific line of text
   * @param {string} content Full document content
   * @param {string} line Line to find
   * @returns {Object|null} Object with page number or null if not found
   */
  getPageForLine(content, line) {
    // Convert line to regex-safe string
    const escapedLine = line.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    
    // Find which page contains this line
    const pageBlocks = content.split(/\[PAGE \d+\]/);
    
    for (let i = 1; i < pageBlocks.length; i++) {
      if (new RegExp(escapedLine, 'i').test(pageBlocks[i])) {
        return { page: i };
      }
    }
    
    return null;
  }
  
  /**
   * Extract table of contents from document
   * @param {string} content Document content
   * @returns {Array<Object>} Array of TOC entries
   */
  extractTableOfContents(content) {
    const tocEntries = [];
    
    // Look for TOC sections
    const tocPatterns = [
      /(?:Table of Contents|CONTENTS|TABLE OF CONTENTS)(?:[\s\n]+)((?:(?:(?:Chapter|Section)\s+)?\d+(?:\.\d+)*[\s\.:]+[^\n]+(?:\s*\.+\s*\d+)?[\s\n]+)+)/i,
      /(?:Index|Contents|TOC)(?:[\s\n]+)((?:(?:(?:Chapter|Section)\s+)?\d+(?:\.\d+)*[\s\.:]+[^\n]+(?:\s*\.+\s*\d+)?[\s\n]+)+)/i
    ];
    
    let tocContent = '';
    
    // Try each pattern
    for (const pattern of tocPatterns) {
      const match = content.match(pattern);
      if (match && match[1]) {
        tocContent = match[1];
        break;
      }
    }
    
    if (!tocContent) {
      return []; // No TOC found
    }
    
    // Parse TOC entries
    const lines = tocContent.split('\n');
    
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed) continue;
      
      // Try to match TOC entry patterns
      const tocPattern = /(?:(?:Chapter|Section)\s+)?(\d+(?:\.\d+)*)[\s\.:]+([^\.\d]+)(?:\.+\s*(\d+))?/i;
      const match = trimmed.match(tocPattern);
      
      if (match) {
        const [, number, title, pageStr] = match;
        
        // Determine level based on number of dots in section number
        const level = number.split('.').length;
        
        // Parse page number if available
        const pageNumber = pageStr ? parseInt(pageStr, 10) : undefined;
        
        tocEntries.push({
          id: `toc-${uuidv4()}`,
          title: title.trim(),
          level,
          pageNumber
        });
      }
    }
    
    return tocEntries;
  }
  
  /**
   * Extract sections from document content
   * @param {string} content Document text content
   * @param {Array<Object>} toc Table of contents entries
   * @returns {Array<Object>} Extracted content sections
   */
  extractSections(content, toc) {
    // Find section patterns
    const headingPatterns = [
      /^[\s\n]*(?:Chapter|Section|Module)\s+(\d+(?:\.\d+)*)[\s\.:]+([^\n]+)/im,
      /^[\s\n]*(\d+(?:\.\d+)*)[\s\.:]+([^\n]+)/im,
      /^[\s\n]*([A-Z][^a-z\n]{3,}[A-Z0-9\s\.:]*)[\s\n]+/m
    ];
    
    const sections = [];
    
    // If we have a TOC, use it as a guide
    if (toc.length > 0) {
      // Create sections based on TOC
      for (let i = 0; i < toc.length; i++) {
        const tocEntry = toc[i];
        let nextTocEntry = i < toc.length - 1 ? toc[i + 1] : null;
        
        // Only use next entry if it's not a subsection
        if (nextTocEntry && nextTocEntry.level > tocEntry.level) {
          // Find next entry at same or higher level
          for (let j = i + 1; j < toc.length; j++) {
            if (toc[j].level <= tocEntry.level) {
              nextTocEntry = toc[j];
              break;
            }
          }
        }
        
        // Extract content between this entry and the next
        const sectionText = this.extractSectionContent(
          content,
          tocEntry.title,
          nextTocEntry?.title
        );
        
        const section = {
          id: tocEntry.id,
          title: tocEntry.title,
          level: tocEntry.level,
          text: sectionText,
          keywords: this.extractKeywords(sectionText),
          isCompliance: false, // Will set later
          isKeyProcedure: false, // Will set later
          isSafetyCritical: false, // Will set later
          pageNumber: tocEntry.pageNumber,
          subsections: [],
          estimatedTimeMinutes: 0, // Will calculate later
          requiresAssessment: false, // Will determine later
          requiresHandsOn: false, // Will determine later
          learningObjectives: this.extractLearningObjectives(sectionText)
        };
        
        // Add to sections array
        if (tocEntry.level === 1) {
          sections.push(section);
        } else {
          // Find parent section
          let parent = this.findParentSection(sections, tocEntry.level - 1);
          if (parent) {
            parent.subsections.push(section);
          } else {
            // If can't find parent, add as top-level
            sections.push(section);
          }
        }
      }
    } else {
      // No TOC, try to extract sections based on patterns
      const lines = content.split('\n');
      let currentSection = null;
      let sectionLines = [];
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // Skip empty lines
        if (!line) continue;
        
        // Check if this line is a heading
        let isHeading = false;
        let headingLevel = 1;
        let headingTitle = '';
        
        for (const pattern of headingPatterns) {
          const match = line.match(pattern);
          if (match) {
            isHeading = true;
            
            if (match[1] && match[2]) {
              // Numbered heading
              const numParts = match[1].split('.');
              headingLevel = numParts.length;
              headingTitle = match[2].trim();
            } else {
              // Unnumbered heading
              headingTitle = match[1].trim();
              // Determine level by capitalization and length
              headingLevel = line === line.toUpperCase() ? 1 : 2;
            }
            
            break;
          }
        }
        
        if (isHeading) {
          // Save previous section if any
          if (currentSection) {
            currentSection.text = sectionLines.join('\n');
            currentSection.keywords = this.extractKeywords(currentSection.text);
            currentSection.learningObjectives = this.extractLearningObjectives(currentSection.text);
            
            // Find appropriate place to add it
            if (currentSection.level === 1) {
              sections.push(currentSection);
            } else {
              let parent = this.findParentSection(sections, currentSection.level - 1);
              if (parent) {
                parent.subsections.push(currentSection);
              } else {
                sections.push(currentSection);
              }
            }
            
            sectionLines = [];
          }
          
          // Create new section
          currentSection = {
            id: `section-${uuidv4()}`,
            title: headingTitle,
            level: headingLevel,
            text: '',
            keywords: [],
            isCompliance: false,
            isKeyProcedure: false,
            isSafetyCritical: false,
            subsections: [],
            estimatedTimeMinutes: 0,
            requiresAssessment: false,
            requiresHandsOn: false,
            learningObjectives: []
          };
          
          // Extract page number if available
          const pageMatch = this.getPageForLine(content, line);
          if (pageMatch) {
            currentSection.pageNumber = pageMatch.page;
          }
        } else if (currentSection) {
          // Add line to current section
          sectionLines.push(line);
        } else {
          // Before first section, create an introduction section
          if (sections.length === 0) {
            currentSection = {
              id: `section-intro-${uuidv4()}`,
              title: 'Introduction',
              level: 1,
              text: line,
              keywords: [],
              isCompliance: false,
              isKeyProcedure: false,
              isSafetyCritical: false,
              subsections: [],
              estimatedTimeMinutes: 0,
              requiresAssessment: false,
              requiresHandsOn: false,
              learningObjectives: []
            };
          } else {
            // Add to last section if available
            sectionLines.push(line);
          }
        }
      }
      
      // Add the last section if any
      if (currentSection) {
        currentSection.text = sectionLines.join('\n');
        currentSection.keywords = this.extractKeywords(currentSection.text);
        currentSection.learningObjectives = this.extractLearningObjectives(currentSection.text);
        
        if (currentSection.level === 1) {
          sections.push(currentSection);
        } else {
          let parent = this.findParentSection(sections, currentSection.level - 1);
          if (parent) {
            parent.subsections.push(currentSection);
          } else {
            sections.push(currentSection);
          }
        }
      }
    }
    
    return sections;
  }
  
  /**
   * Extract a section of text from content based on section title
   * @param {string} content Full document content
   * @param {string} sectionTitle Title of the section to extract
   * @param {string|null} nextSectionTitle Optional title of the next section
   * @returns {string} Extracted section text
   */
  extractSectionContent(content, sectionTitle, nextSectionTitle) {
    // Escape special regex characters
    const escapedTitle = sectionTitle.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    
    // Find the section start
    const sectionPattern = new RegExp(`(^|\\n)\\s*${escapedTitle}\\s*(?:\\n|$)`, 'i');
    const sectionMatch = content.match(sectionPattern);
    
    if (!sectionMatch) {
      return ''; // Section not found
    }
    
    const startIndex = sectionMatch.index + sectionMatch[0].length;
    let endIndex = content.length;
    
    // If next section title is provided, find its position
    if (nextSectionTitle) {
      const escapedNextTitle = nextSectionTitle.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const nextSectionPattern = new RegExp(`(^|\\n)\\s*${escapedNextTitle}\\s*(?:\\n|$)`, 'i');
      const nextSectionMatch = content.slice(startIndex).match(nextSectionPattern);
      
      if (nextSectionMatch) {
        endIndex = startIndex + nextSectionMatch.index;
      }
    }
    
    // Extract the section content
    return content.slice(startIndex, endIndex).trim();
  }
  
  /**
   * Find a parent section for a given subsection level
   * @param {Array<Object>} sections Array of sections to search
   * @param {number} level Parent level to find
   * @returns {Object|null} Parent section or null if not found
   */
  findParentSection(sections, level) {
    if (sections.length === 0) return null;
    
    // Find last section at the required level
    for (let i = sections.length - 1; i >= 0; i--) {
      if (sections[i].level === level) {
        return sections[i];
      }
      
      // Recursively check subsections
      const parent = this.findParentSection(sections[i].subsections, level);
      if (parent) return parent;
    }
    
    return null;
  }
  
  /**
   * Extract learning objectives from a section of text
   * @param {string} text Section text
   * @returns {Array<string>} Array of learning objectives
   */
  extractLearningObjectives(text) {
    const objectives = [];
    
    // Look for explicit learning objectives sections
    const objectivePhrases = [
      /learning objectives?:?(?:\s*\((?:by )?the end of this (?:section|module|course|training)(?:,)? (?:you|the trainee|the student) (?:should|will|shall) be able to:?\))?(.+?)(?:\n\n|\n[A-Z]|$)/is,
      /upon completion(?:,)? (?:you|the trainee|the student) (?:should|will|shall) be able to:?(.+?)(?:\n\n|\n[A-Z]|$)/is,
      /objectives?:(.+?)(?:\n\n|\n[A-Z]|$)/is
    ];
    
    for (const pattern of objectivePhrases) {
      const match = text.match(pattern);
      if (match && match[1]) {
        // Split by line breaks or bullet points
        const objectivesText = match[1];
        const objList = objectivesText.split(/(?:\r?\n|\*|\â€¢|\-|\d+\.|[A-Za-z]\))/);
        
        for (let obj of objList) {
          obj = obj.trim();
          if (obj && obj.length > 10) {
            objectives.push(obj);
          }
        }
        
        // If objectives found, return them
        if (objectives.length > 0) {
          return objectives;
        }
      }
    }
    
    // If no explicit learning objectives, try to infer them from the content
    if (objectives.length === 0) {
      // Extract key sentences that might be objectives
      const sentences = text.match(/[^.!?]+[.!?]+/g) || [];
      
      for (const sentence of sentences) {
        const trimmed = sentence.trim();
        
        // Look for sentences that might be objectives
        if (
          /(?:learn|understand|know|identify|demonstrate|explain|describe|apply|perform|analyze|evaluate|create)/i.test(trimmed) &&
          trimmed.length > 20 &&
          trimmed.length < 200
        ) {
          objectives.push(trimmed);
        }
      }
      
      // Limit to top 3 inferred objectives
      return objectives.slice(0, 3);
    }
    
    return objectives;
  }
  
  /**
   * Extract keywords from text
   * @param {string} text Text to analyze
   * @returns {Array<string>} Array of keywords
   */
  extractKeywords(text) {
    const keywords = [];
    const stopWords = new Set([
      'a', 'an', 'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'with',
      'by', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had',
      'do', 'does', 'did', 'this', 'that', 'these', 'those', 'of', 'from'
    ]);
    
    // Extract words
    const words = text.toLowerCase().match(/\b[a-z]{3,}\b/g) || [];
    
    // Count word frequencies
    const wordCounts = new Map();
    
    for (const word of words) {
      if (!stopWords.has(word)) {
        const count = wordCounts.get(word) || 0;
        wordCounts.set(word, count + 1);
      }
    }
    
    // Sort by frequency
    const sortedWords = Array.from(wordCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .map(entry => entry[0]);
    
    // Take top 10 keywords
    keywords.push(...sortedWords.slice(0, 10));
    
    // Look for technical terms and phrases
    const phrases = text.match(/\b[A-Z][a-z]+ [A-Z][a-z]+\b|\b[A-Z]{2,}\b|\b[A-Z][a-z]+(?:-[A-Z][a-z]+)+\b/g) || [];
    
    // Add unique phrases
    for (const phrase of phrases) {
      if (!keywords.includes(phrase.toLowerCase())) {
        keywords.push(phrase);
        if (keywords.length >= 15) break; // Limit to 15 keywords total
      }
    }
    
    return keywords;
  }
  
  /**
   * Estimate the time needed to cover each section
   * @param {Array<Object>} sections Content sections
   */
  estimateSectionTimes(sections) {
    // Calculate time based on content length, complexity
    const processSection = (section) => {
      // Base time: 1 minute per 100 words (reading speed)
      const wordCount = section.text.split(/\s+/).length;
      let timeMinutes = wordCount / 100;
      
      // Adjust for complexity
      if (section.isCompliance || section.isSafetyCritical) {
        timeMinutes *= 1.5; // Compliance topics take longer
      }
      
      // Adjust for procedures
      if (section.isKeyProcedure) {
        timeMinutes *= 1.3; // Procedures take more time to explain
      }
      
      // Minimum time per section
      timeMinutes = Math.max(5, timeMinutes);
      
      // Round to nearest minute
      section.estimatedTimeMinutes = Math.round(timeMinutes);
      
      // Process subsections
      section.subsections.forEach(processSection);
    };
    
    // Process all top-level sections
    sections.forEach(processSection);
  }
  
  /**
   * Identify compliance and safety-critical content
   * @param {Array<Object>} sections Content sections
   */
  identifyComplianceContent(sections) {
    const processSection = (section) => {
      const text = section.text.toLowerCase();
      
      // Check for compliance phrases
      section.isCompliance = this.compliancePhrasePatterns.some(pattern => pattern.test(text));
      
      // Check for safety-critical content
      section.isSafetyCritical = this.safetyPhrasePatterns.some(pattern => pattern.test(text));
      
      // Check for procedural content
      section.isKeyProcedure = /(?:procedure|instructions|steps|checklist|sequence)/i.test(text) &&
                               /(?:^\s*\d+\.|^\s*[a-z]\.|^\s*\W+\s)/m.test(text); // Has numbered steps
      
      // Determine if section requires assessment
      section.requiresAssessment = section.isCompliance || 
                                  section.isSafetyCritical ||
                                  /(?:must|shall|required|critical)/i.test(text);
      
      // Determine if section requires hands-on practice
      section.requiresHandsOn = section.isKeyProcedure ||
                                /(?:demonstrate|practice|perform|operate|use)/i.test(text);
      
      // Process subsections
      section.subsections.forEach(processSection);
    };
    
    // Process all top-level sections
    sections.forEach(processSection);
  }
  
  /**
   * Extract key terms and definitions from content
   * @param {string} content Full document content
   * @param {Array<Object>} sections Content sections
   * @returns {Promise<Array<Object>>} Array of key terms
   */
  async extractKeyTerms(content, sections) {
    const keyTerms = [];
    
    // Look for dedicated glossary or definitions section
    const glossarySectionNames = ['glossary', 'definitions', 'terminology', 'terms and definitions'];
    
    // Find glossary section if it exists
    const glossarySection = this.findSectionByNames(sections, glossarySectionNames);
    
    if (glossarySection) {
      // Process the glossary section
      const terms = this.extractDefinitionsFromGlossary(glossarySection.text);
      keyTerms.push(...terms);
    }
    
    // If no dedicated glossary, or it's too small, extract inline definitions
    if (keyTerms.length < 5) {
      const inlineTerms = this.extractInlineDefinitions(content, sections);
      
      // Add terms not already found
      for (const term of inlineTerms) {
        if (!keyTerms.some(kt => kt.term.toLowerCase() === term.term.toLowerCase())) {
          keyTerms.push(term);
        }
      }
    }
    
    // Sort by importance
    keyTerms.sort((a, b) => b.importance - a.importance);
    
    return keyTerms;
  }
  
  /**
   * Find a section by matching its title against a list of potential names
   * @param {Array<Object>} sections Sections to search
   * @param {Array<string>} names Potential section names
   * @returns {Object|null} Matching section or null
   */
  findSectionByNames(sections, names) {
    // Helper to check a single section and its subsections
    const checkSection = (section) => {
      // Check if this section's title matches any of the names
      if (names.some(name => 
        section.title.toLowerCase().includes(name.toLowerCase())
      )) {
        return section;
      }
      
      // Check subsections
      for (const subsection of section.subsections) {
        const match = checkSection(subsection);
        if (match) return match;
      }
      
      return null;
    };
    
    // Check all top-level sections
    for (const section of sections) {
      const match = checkSection(section);
      if (match) return match;
    }
    
    return null;
  }
  
  /**
   * Extract definitions from a glossary section
   * @param {string} glossaryText Text of glossary section
   * @returns {Array<Object>} Array of key terms
   */
  extractDefinitionsFromGlossary(glossaryText) {
    const terms = [];
    
    // Common patterns in glossaries
    // 1. Term - Definition
    // 2. Term: Definition
    // 3. Term â€” Definition
    
    const glossaryPatterns = [
      /([A-Za-z\s\-\/]+)(?:\s*[-â€“â€”:]\s*)([^\n]+)/g,
      /([A-Za-z\s\-\/]+)(?:\s*\n\s*)([^\n]+)/g
    ];
    
    for (const pattern of glossaryPatterns) {
      let match;
      while ((match = pattern.exec(glossaryText)) !== null) {
        const term = match[1].trim();
        const definition = match[2].trim();
        
        // Skip if too short
        if (term.length < 2 || definition.length < 5) continue;
        
        terms.push({
          term,
          definition,
          context: 'From glossary',
          importance: this.calculateTermImportance(term, definition),
          section: 'Glossary'
        });
      }
    }
    
    return terms;
  }
  
  /**
   * Extract inline definitions from content
   * @param {string} content Full document content
   * @param {Array<Object>} sections Content sections
   * @returns {Array<Object>} Array of key terms
   */
  extractInlineDefinitions(content, sections) {
    const terms = [];
    
    // Pattern 1: Term means/refers to/is defined as Definition
    const pattern1 = /(?<term>[A-Z][A-Za-z\s\-\/]{2,})(?:\s+is\s+defined\s+as\s+|\s+means\s+|\s+refers\s+to\s+|\s+is\s+)(?<def>[^\.;]+)/g;
    
    // Pattern 2: Term (Definition)
    const pattern2 = /(?<term>[A-Z][A-Za-z\s\-\/]{2,})(?:\s+\((?<def>[^)]+)\))/g;
    
    // Pattern 3: "Term" - Definition
    const pattern3 = /["'](?<term>[A-Za-z\s\-\/]{2,})["'](?:\s*[-â€“â€”:]\s*)(?<def>[^\.;]+)/g;
    
    const patterns = [pattern1, pattern2, pattern3];
    
    for (const pattern of patterns) {
      let match;
      while ((match = pattern.exec(content)) !== null) {
        const term = match.groups?.term?.trim() || match[1]?.trim();
        const definition = match.groups?.def?.trim() || match[2]?.trim();
        
        // Skip if too short
        if (!term || !definition || term.length < 2 || definition.length < 5) continue;
        
        // Find the section where this term appears
        const section = this.findSectionContainingText(sections, match[0]);
        const sectionName = section ? section.title : 'Unknown Section';
        
        terms.push({
          term,
          definition,
          context: match[0],
          importance: this.calculateTermImportance(term, definition),
          section: sectionName
        });
      }
    }
    
    return terms;
  }
  
  /**
   * Find a section containing specific text
   * @param {Array<Object>} sections Sections to search
   * @param {string} text Text to find
   * @returns {Object|null} Matching section or null
   */
  findSectionContainingText(sections, text) {
    // Helper to check a single section and its subsections
    const checkSection = (section) => {
      // Check if this section contains the text
      if (section.text.includes(text)) {
        return section;
      }
      
      // Check subsections
      for (const subsection of section.subsections) {
        const match = checkSection(subsection);
        if (match) return match;
      }
      
      return null;
    };
    
    // Check all top-level sections
    for (const section of sections) {
      const match = checkSection(section);
      if (match) return match;
    }
    
    return null;
  }
  
  /**
   * Calculate the importance of a term
   * @param {string} term Term text
   * @param {string} definition Definition text
   * @returns {number} Importance score (1-10)
   */
  calculateTermImportance(term, definition) {
    let importance = 5; // Base score
    
    // Check if term appears in compliance contexts
    if (this.compliancePhrasePatterns.some(pattern => pattern.test(definition))) {
      importance += 3;
    }
    
    // Check if term is safety related
    if (this.safetyPhrasePatterns.some(pattern => pattern.test(definition))) {
      importance += 2;
    }
    
    // Check if term is in ALL CAPS (often important)
    if (term === term.toUpperCase() && term.length > 1) {
      importance += 1;
    }
    
    // Cap at 10
    return Math.min(10, importance);
  }
  
  /**
   * Identify compliance procedures from sections
   * @param {Array<Object>} sections Content sections
   * @returns {Promise<Array<Object>>} Array of compliance procedures
   */
  async identifyComplianceProcedures(sections) {
    const procedures = [];
    
    // Process sections to identify procedures
    const processSection = (section, path = '') => {
      const currentPath = path ? `${path} > ${section.title}` : section.title;
      
      // Check if this section is a compliance procedure
      if (section.isCompliance || section.isSafetyCritical || section.isKeyProcedure) {
        // Extract procedure steps
        const steps = this.extractProcedureSteps(section.text);
        
        if (steps.length > 0) {
          // Create procedure entry
          const procedure = {
            id: `proc-${uuidv4()}`,
            title: section.title,
            description: this.extractFirstParagraph(section.text),
            steps,
            criticalityLevel: section.isSafetyCritical ? 'high' : 
                             section.isCompliance ? 'medium' : 'low',
            section: currentPath,
            requiresSignoff: section.isSafetyCritical || 
                           /(?:sign|signature|approval|authorize)/i.test(section.text),
            requiresRecordKeeping: /(?:record|document|log|track)/i.test(section.text),
          };
          
          // Extract regulatory references
          const regMatch = section.text.match(
            /(?:in accordance with|as required by|as specified in|as per|according to|complies with)\s+([^\.;]+)/i
          );
          
          if (regMatch && regMatch[1]) {
            procedure.regulation = regMatch[1].trim();
            
            // Guess regulatory authority
            if (/FAA|Federal Aviation/i.test(regMatch[1])) {
              procedure.regulatoryAuthority = 'FAA';
            } else if (/EASA|European Aviation/i.test(regMatch[1])) {
              procedure.regulatoryAuthority = 'EASA';
            } else if (/ICAO|International Civil Aviation/i.test(regMatch[1])) {
              procedure.regulatoryAuthority = 'ICAO';
            } else if (/CAA|Civil Aviation Authority/i.test(regMatch[1])) {
              procedure.regulatoryAuthority = 'CAA';
            }
          }
          
          // Create assessment criteria if needed
          if (section.requiresAssessment) {
            procedure.assessmentCriteria = this.generateAssessmentCriteria(steps);
          }
          
          procedures.push(procedure);
        }
      }
      
      // Process subsections
      section.subsections.forEach(subsection => {
        processSection(subsection, currentPath);
      });
    };
    
    // Process all top-level sections
    sections.forEach(section => {
      processSection(section);
    });
    
    return procedures;
  }
  
  /**
   * Extract the first paragraph from text
   * @param {string} text Section text
   * @returns {string} First paragraph
   */
  extractFirstParagraph(text) {
    // Try to find the first non-empty paragraph
    const paragraphs = text.split(/\n\s*\n/);
    
    for (const paragraph of paragraphs) {
      const trimmed = paragraph.trim();
      if (trimmed && trimmed.length > 20) {
        return trimmed;
      }
    }
    
    // If no good paragraph found, return the first sentence
    const sentences = text.match(/[^.!?]+[.!?]+/g) || [];
    return sentences.length > 0 ? sentences[0].trim() : text.slice(0, 100).trim();
  }
  
  /**
   * Extract procedure steps from text
   * @param {string} text Section text
   * @returns {Array<string>} Array of procedure steps
   */
  extractProcedureSteps(text) {
    const steps = [];
    
    // Look for numbered or bulleted lists
    const listPatterns = [
      /(?:^|\n)\s*(\d+)[\.\)]\s+([^\n]+)/g, // Numbered list: "1. Step one"
      /(?:^|\n)\s*([a-z])[\.\)]\s+([^\n]+)/g, // Letter list: "a. Step one"
      /(?:^|\n)\s*[\*\-â€¢]\s+([^\n]+)/g // Bullet list: "â€¢ Step one"
    ];
    
    for (const pattern of listPatterns) {
      let match;
      while ((match = pattern.exec(text)) !== null) {
        // Different handling based on pattern
        if (pattern.source.includes('\\*')) {
          // Bullet pattern
          steps.push(match[1].trim());
        } else {
          // Numbered or letter pattern
          steps.push(match[2].trim());
        }
      }
      
      // If steps found, return them
      if (steps.length > 0) return steps;
    }
    
    // If no list format found, try to split by sentences
    if (steps.length === 0) {
      const sentences = text.match(/[^.!?]+[.!?]+/g) || [];
      
      // Filter sentences that look like instructions
      const instructionSentences = sentences.filter(sentence => 
        /(?:must|shall|should|ensure|verify|check|perform|complete|review)/i.test(sentence)
      );
      
      if (instructionSentences.length > 0) {
        // Limit to a reasonable number of steps
        return instructionSentences.slice(0, 10).map(s => s.trim());
      }
    }
    
    return steps;
  }
  
  /**
   * Generate assessment criteria from procedure steps
   * @param {Array<string>} steps Procedure steps
   * @returns {Array<string>} Array of assessment criteria
   */
  generateAssessmentCriteria(steps) {
    const criteria = [];
    
    // Convert steps to assessment criteria
    for (const step of steps) {
      // Skip very short steps
      if (step.length < 10) continue;
      
      // Convert imperative to assessment criteria
      let criterion = step
        .replace(/^(?:please|must|shall|should|)\s+/i, '')
        .replace(/^(?:the (?:trainee|student|operator|user|pilot))\s+/i, '');
      
      // Ensure it starts with a verb
      const firstWord = criterion.split(/\s+/)[0];
      if (!/^(?:check|verify|ensure|confirm|perform|demonstrate|complete|identify)/i.test(firstWord)) {
        criterion = `Correctly ${criterion}`;
      }
      
      criteria.push(criterion);
    }
    
    return criteria;
  }
  
  /**
   * Find all sections matching a specific criteria
   * @param {Array<Object>} sections Sections to search
   * @param {Function} criteriaFn Function that returns true for matching sections
   * @returns {Array<Object>} Matching sections
   */
  findAllSectionsWithCriteria(sections, criteriaFn) {
    const matches = [];
    
    const searchSection = (section) => {
      // Check if this section matches criteria
      if (criteriaFn(section)) {
        matches.push(section);
      }
      
      // Search subsections
      section.subsections.forEach(searchSection);
    };
    
    // Search all top-level sections
    sections.forEach(searchSection);
    
    return matches;
  }
}

// =====================================================================
// SESSION PLAN GENERATOR
// =====================================================================

/**
 * SessionPlanGenerator class handles the generation of training session
 * plans based on extracted document content
 */
class SessionPlanGenerator {
  /**
   * Create a new SessionPlanGenerator
   */
  constructor() {
    this.activityTypes = [
      'lecture',
      'discussion',
      'demonstration',
      'practice',
      'assessment',
      'break'
    ];
  }
  
  /**
   * Generate session plans based on extracted content
   * @param {Object} content Extracted document content
   * @param {Object} options Session generation options
   * @returns {Promise<Array<Object>>} Array of session plans
   */
  async generateSessionPlans(content, options = {}) {
    try {
      // Set default options
      const defaultOptions = {
        sessionDuration: 120, // 2 hours
        maxSessionCount: 5,
        sessionFormat: 'classroom',
        studentLevel: 'intermediate',
        includeBreaks: true,
        breakDuration: 15 // minutes
      };
      
      const sessionOptions = { ...defaultOptions, ...options };
      
      // Calculate total content time
      const totalContentMinutes = this.calculateTotalContentTime(content.sections);
      
      // Calculate how many sessions we need (respecting max session count)
      const sessionCount = Math.min(
        sessionOptions.maxSessionCount,
        Math.ceil(totalContentMinutes / sessionOptions.sessionDuration)
      );
      
      // Divide content into logical session chunks
      const sessionContentGroups = this.divideContentIntoSessions(
        content.sections,
        sessionCount
      );
      
      const sessionPlans = [];
      
      // Generate each session
      for (let i = 0; i < sessionContentGroups.length; i++) {
        const sessionContent = sessionContentGroups[i];
        
        // Create instructor session plan
        const instructorPlan = await this.createInstructorSessionPlan(
          sessionContent,
          content,
          i + 1,
          sessionContentGroups.length,
          sessionOptions
        );
        
        // Create student session plan (simplified version of instructor plan)
        const studentPlan = this.createStudentSessionPlan(instructorPlan);
        
        sessionPlans.push(instructorPlan, studentPlan);
      }
      
      return sessionPlans;
    } catch (error) {
      console.error('Error generating session plans:', error);
      throw new Error('Failed to generate session plans');
    }
  }
  
  /**
   * Calculate the total content time for all sections
   * @param {Array<Object>} sections Content sections
   * @returns {number} Total time in minutes
   */
  calculateTotalContentTime(sections) {
    let totalMinutes = 0;
    
    const processSection = (section) => {
      totalMinutes += section.estimatedTimeMinutes;
      
      section.subsections.forEach(processSection);
    };
    
    sections.forEach(processSection);
    
    // Add some extra time for assessments, discussions, etc.
    totalMinutes = Math.round(totalMinutes * 1.2);
    
    return totalMinutes;
  }
  
  /**
   * Divide content into logical session groups
   * @param {Array<Object>} sections Content sections
   * @param {number} sessionCount Desired number of sessions
   * @returns {Array<Array<Object>>} Array of section groups for each session
   */
  divideContentIntoSessions(sections, sessionCount) {
    // First, flatten the section hierarchy into a list of all sections
    const allSections = [];
    
    const flattenSections = (section, level = 0) => {
      // Clone section without subsections to avoid circular references
      const flatSection = {
        ...section,
        subsections: [],
        level // Override level to track original hierarchy
      };
      
      allSections.push(flatSection);
      
      // Process subsections
      section.subsections.forEach(subsection => {
        flattenSections(subsection, level + 1);
      });
    };
    
    sections.forEach(section => {
      flattenSections(section);
    });
    
    // Sort by compliance/safety importance, then by original order
    allSections.sort((a, b) => {
      // Critical sections come first
      if (a.isSafetyCritical !== b.isSafetyCritical) {
        return a.isSafetyCritical ? -1 : 1;
      }
      
      // Then compliance sections
      if (a.isCompliance !== b.isCompliance) {
        return a.isCompliance ? -1 : 1;
      }
      
      // Then keep original hierarchy order
      return allSections.indexOf(a) - allSections.indexOf(b);
    });
    
    // Calculate total time
    const totalMinutes = allSections.reduce((sum, section) => sum + section.estimatedTimeMinutes, 0);
    
    // Calculate target minutes per session
    const targetMinutesPerSession = Math.ceil(totalMinutes / sessionCount);
    
    // Group sections into sessions
    const sessionGroups = [];
    let currentGroup = [];
    let currentGroupMinutes = 0;
    
    for (const section of allSections) {
      // If adding this section would exceed target time and we already have some content,
      // start a new group
      if (currentGroupMinutes + section.estimatedTimeMinutes > targetMinutesPerSession && 
          currentGroup.length > 0 &&
          sessionGroups.length < sessionCount - 1) { // Ensure we don't create too many groups
        sessionGroups.push(currentGroup);
        currentGroup = [];
        currentGroupMinutes = 0;
      }
      
      // Add section to current group
      currentGroup.push(section);
      currentGroupMinutes += section.estimatedTimeMinutes;
    }
    
    // Add the last group if not empty
    if (currentGroup.length > 0) {
      sessionGroups.push(currentGroup);
    }
    
    // If we have too few groups, try to split the largest group
    while (sessionGroups.length < sessionCount) {
      // Find the largest group
      let largestGroupIndex = 0;
      let largestGroupTime = 0;
      
      sessionGroups.forEach((group, index) => {
        const groupTime = group.reduce((sum, section) => sum + section.estimatedTimeMinutes, 0);
        if (groupTime > largestGroupTime) {
          largestGroupTime = groupTime;
          largestGroupIndex = index;
        }
      });
      
      // If largest group has only one section, we can't split further
      if (sessionGroups[largestGroupIndex].length <= 1) {
        break;
      }
      
      // Split the largest group into two
      const groupToSplit = sessionGroups[largestGroupIndex];
      const midpoint = Math.ceil(groupToSplit.length / 2);
      
      const firstHalf = groupToSplit.slice(0, midpoint);
      const secondHalf = groupToSplit.slice(midpoint);
      
      // Replace the original group with the two new groups
      sessionGroups.splice(largestGroupIndex, 1, firstHalf, secondHalf);
    }
    
    // If we have too many groups, merge the smallest adjacent groups
    while (sessionGroups.length > sessionCount) {
      // Find the smallest adjacent groups
      let smallestPairIndex = 0;
      let smallestPairTime = Number.MAX_VALUE;
      
      for (let i = 0; i < sessionGroups.length - 1; i++) {
        const group1Time = sessionGroups[i].reduce(
          (sum, section) => sum + section.estimatedTimeMinutes, 0
        );
        const group2Time = sessionGroups[i + 1].reduce(
          (sum, section) => sum + section.estimatedTimeMinutes, 0
        );
        
        const pairTime = group1Time + group2Time;
        if (pairTime < smallestPairTime) {
          smallestPairTime = pairTime;
          smallestPairIndex = i;
        }
      }
      
      // Merge the smallest adjacent groups
      const mergedGroup = [
        ...sessionGroups[smallestPairIndex],
        ...sessionGroups[smallestPairIndex + 1]
      ];
      
      // Replace the two groups with the merged group
      sessionGroups.splice(smallestPairIndex, 2, mergedGroup);
    }
    
    return sessionGroups;
  }
  
  /**
   * Create an instructor session plan
   * @param {Array<Object>} sessionContent Content sections for this session
   * @param {Object} content Full extracted content
   * @param {number} sessionIndex Index of this session (1-based)
   * @param {number} totalSessions Total number of sessions
   * @param {Object} options Session options
   * @returns {Promise<Object>} Instructor session plan
   */
  async createInstructorSessionPlan(
    sessionContent, 
    content, 
    sessionIndex, 
    totalSessions,
    options
  ) {
    // Calculate total session time
    const sessionMinutes = sessionContent.reduce(
      (sum, section) => sum + section.estimatedTimeMinutes,
      0
    );
    
    // Calculate actual session duration, allowing for breaks and assessments
    const totalSessionMinutes = Math.min(
      options.sessionDuration,
      sessionMinutes + (options.includeBreaks ? options.breakDuration : 0) + 15 // Extra 15 min for assessment
    );
    
    // Create session title
    const sessionTitle = `Training Session ${sessionIndex}: ${
      sessionContent[0]?.title || 'Training Content'
    }`;
    
    // Collect all learning objectives
    const learningObjectives = [];
    sessionContent.forEach(section => {
      if (section.learningObjectives && section.learningObjectives.length > 0) {
        learningObjectives.push(...section.learningObjectives);
      }
    });
    
    // Create session activities
    const activities = this.createSessionActivities(
      sessionContent, 
      content,
      totalSessionMinutes,
      options
    );
    
    // Create materials list
    const materials = this.createSessionMaterials(sessionContent, content);
    
    // Create assessments
    const assessments = this.createSessionAssessments(sessionContent, content);
    
    // Create compliance coverage
    const complianceCoverage = this.createComplianceCoverage(
      sessionContent, 
      content.complianceProcedures,
      assessments
    );
    
    // Create instructor notes
    const instructorNotes = this.createInstructorNotes(
      sessionContent, 
      sessionIndex, 
      totalSessions
    );
    
    // Create student preparation guidance
    const studentPreparation = this.createStudentPreparation(sessionContent);
    
    // Create session plan
    const sessionPlan = {
      id: `session-instructor-${uuidv4()}`,
      planType: 'instructor',
      title: sessionTitle,
      description: this.createSessionDescription(sessionContent, sessionIndex, totalSessions),
      duration: totalSessionMinutes,
      targetAudience: `Aviation personnel - ${options.studentLevel} level`,
      learningObjectives: learningObjectives.slice(0, 5), // Limit to top 5
      prerequisites: sessionIndex > 1 ? [`Completion of Session ${sessionIndex - 1}`] : [],
      activities,
      materials,
      assessments,
      complianceCoverage,
      instructorNotes,
      studentPreparation
    };
    
    return sessionPlan;
  }
  
  /**
   * Create session activities based on content
   * @param {Array<Object>} sessionContent Content sections
   * @param {Object} content Full extracted content
   * @param {number} totalMinutes Total session minutes
   * @param {Object} options Session options
   * @returns {Array<Object>} Session activities
   */
  createSessionActivities(sessionContent, content, totalMinutes, options) {
    const activities = [];
    
    // Start with introduction
    activities.push({
      id: `activity-intro-${uuidv4()}`,
      title: 'Session Introduction',
      type: 'lecture',
      description: 'Overview of session topics and learning objectives',
      duration: 5, // 5 minutes
      materials: ['Session outline', 'Presentation slides'],
      instructorNotes: 'Begin with a brief overview of the session structure and key learning objectives. Establish relevance to aviation operations.',
      contentReferences: []
    });
    
    // Calculate time available for content
    let remainingMinutes = totalMinutes - 5; // Subtract intro time
    
    // Reserve time for breaks if enabled
    if (options.includeBreaks && totalMinutes > 60) {
      remainingMinutes -= options.breakDuration;
    }
    
    // Reserve time for assessment
    const assessmentTime = 10; // 10 minutes
    remainingMinutes -= assessmentTime;
    
    // Calculate how much time to allocate for each section
    const totalContentTime = sessionContent.reduce(
      (sum, section) => sum + section.estimatedTimeMinutes, 
      0
    );
    
    // If content time exceeds remaining time, we need to scale activities
    const scaleFactor = Math.min(1, remainingMinutes / totalContentTime);
    
    // Process each content section
    let currentMinuteCount = 5; // Start after intro
    
    for (const section of sessionContent) {
      // Scale section time if necessary
      const sectionMinutes = Math.round(section.estimatedTimeMinutes * scaleFactor);
      
      // Determine best activity type based on section content
      let activityType = 'lecture'; // Default
      
      if (section.isKeyProcedure || section.requiresHandsOn) {
        activityType = options.sessionFormat === 'online' ? 'demonstration' : 'practice';
      } else if (section.isCompliance || section.isSafetyCritical) {
        activityType = 'lecture';
      } else if (section.text.length < 500) { // Short sections
        activityType = 'discussion';
      }
      
      // Create activity for this section
      const activity = {
        id: `activity-${uuidv4()}`,
        title: section.title,
        type: activityType,
        description: this.createActivityDescription(section, activityType),
        duration: sectionMinutes,
        materials: this.getMaterialsForSection(section),
        instructorNotes: this.createInstructorNotesForSection(section),
        contentReferences: [section.id]
      };
      
      activities.push(activity);
      
      currentMinuteCount += sectionMinutes;
      
      // Add break if needed (after approximately half the content)
      if (options.includeBreaks && 
          currentMinuteCount > totalMinutes / 2 && 
          !activities.some(a => a.type === 'break')) {
        activities.push({
          id: `activity-break-${uuidv4()}`,
          title: 'Break',
          type: 'break',
          description: 'Short break for rest and refreshment',
          duration: options.breakDuration,
          materials: [],
          contentReferences: []
        });
        
        currentMinuteCount += options.breakDuration;
      }
    }
    
    // Add final assessment activity
    activities.push({
      id: `activity-assessment-${uuidv4()}`,
      title: 'Knowledge Check',
      type: 'assessment',
      description: 'Brief assessment to verify understanding of key concepts',
      duration: assessmentTime,
      materials: ['Assessment form', 'Answer sheets'],
      instructorNotes: 'Administer a brief quiz to verify understanding of critical concepts. Focus on safety and compliance items.',
      contentReferences: sessionContent.map(section => section.id)
    });
    
    return activities;
  }
  
  /**
   * Create a description for an activity based on section and type
   * @param {Object} section Content section
   * @param {string} activityType Type of activity
   * @returns {string} Activity description
   */
  createActivityDescription(section, activityType) {
    switch (activityType) {
      case 'lecture':
        return `Presentation covering ${section.title} concepts, principles, and requirements`;
      
      case 'discussion':
        return `Group discussion about ${section.title} to explore experiences and best practices`;
      
      case 'demonstration':
        return `Demonstration of ${section.title} showing proper techniques and procedures`;
      
      case 'practice':
        return `Hands-on practice of ${section.title} procedures to build proficiency`;
      
      default:
        return `Learning activity focused on ${section.title}`;
    }
  }
  
  /**
   * Get materials needed for a section
   * @param {Object} section Content section
   * @returns {Array<string>} Array of material names
   */
  getMaterialsForSection(section) {
    const materials = ['Presentation slides', 'Handouts'];
    
    if (section.isKeyProcedure || section.requiresHandsOn) {
      materials.push('Procedure checklist');
      
      // Look for equipment mentions in the text
      const equipmentMatch = section.text.match(/(?:equipment|tools|materials) (?:needed|required|necessary):\s*([^.;]+)/i);
      if (equipmentMatch && equipmentMatch[1]) {
        // Extract equipment items
        const equipmentItems = equipmentMatch[1]
          .split(/,|\band\b/)
          .map(item => item.trim())
          .filter(item => item.length > 0);
        
        materials.push(...equipmentItems);
      } else {
        // Generic equipment for hands-on activities
        materials.push('Training equipment');
      }
    }
    
    if (section.isCompliance || section.isSafetyCritical) {
      materials.push('Regulatory references');
      materials.push('Compliance checklist');
    }
    
    return materials;
  }
  
  /**
   * Create instructor notes for a specific section
   * @param {Object} section Content section
   * @returns {string} Instructor notes
   */
  createInstructorNotesForSection(section) {
    let notes = '';
    
    if (section.isCompliance) {
      notes += 'Emphasize regulatory requirements and the importance of strict compliance. ';
    }
    
    if (section.isSafetyCritical) {
      notes += 'Highlight safety implications and potential consequences of improper execution. ';
    }
    
    if (section.isKeyProcedure) {
      notes += 'Demonstrate the procedure step-by-step before having students practice. ';
    }
    
    if (section.requiresAssessment) {
      notes += 'Check for understanding through questioning before proceeding. ';
    }
    
    // Add notes based on section content length
    if (section.text.length > 2000) {
      notes += 'This is a substantial section; consider using various engagement techniques to maintain attention. ';
    } else if (section.text.length < 500) {
      notes += 'This is a brief section; consider supplementing with relevant examples from experience. ';
    }
    
    return notes.trim();
  }
  
  /**
   * Create session materials list
   * @param {Array<Object>} sessionContent Session content sections
   * @param {Object} content Full extracted content
   * @returns {Array<Object>} Session materials
   */
  createSessionMaterials(sessionContent, content) {
    const materials = [];
    const materialSet = new Set();
    
    // Standard materials
    materials.push({
      id: `material-${uuidv4()}`,
      title: 'Presentation Slides',
      type: 'presentation',
      description: 'Slides covering key concepts, regulations, and procedures',
      required: true
    });
    
    materials.push({
      id: `material-${uuidv4()}`,
      title: 'Student Handouts',
      type: 'handout',
      description: 'Summary of key points, checklists, and reference information',
      required: true
    });
    
    // Add materials for each section
    for (const section of sessionContent) {
      // Special materials for procedures
      if (section.isKeyProcedure && !materialSet.has('Procedure Documentation')) {
        materials.push({
          id: `material-${uuidv4()}`,
          title: 'Procedure Documentation',
          type: 'reference',
          description: 'Detailed step-by-step procedures for required tasks',
          required: true
        });
        
        materialSet.add('Procedure Documentation');
      }
      
      // Materials for compliance sections
      if (section.isCompliance && !materialSet.has('Regulatory References')) {
        materials.push({
          id: `material-${uuidv4()}`,
          title: 'Regulatory References',
          type: 'reference',
          description: 'Relevant regulatory documents and compliance guidelines',
          source: this.extractRegulatoryReferences(section.text),
          required: true
        });
        
        materialSet.add('Regulatory References');
      }
      
      // Equipment for hands-on activities
      if (section.requiresHandsOn && !materialSet.has('Training Equipment')) {
        materials.push({
          id: `material-${uuidv4()}`,
          title: 'Training Equipment',
          type: 'equipment',
          description: 'Equipment for hands-on practice and demonstration',
          required: true
        });
        
        materialSet.add('Training Equipment');
      }
    }
    
    // Assessment materials
    if (!materialSet.has('Assessment Materials')) {
      materials.push({
        id: `material-${uuidv4()}`,
        title: 'Assessment Materials',
        type: 'handout',
        description: 'Knowledge checks, quizzes, and practical evaluation forms',
        required: true
      });
      
      materialSet.add('Assessment Materials');
    }
    
    return materials;
  }
  
  /**
   * Extract regulatory references from text
   * @param {string} text Section text
   * @returns {string} Extracted references or default text
   */
  extractRegulatoryReferences(text) {
    // Look for regulatory references
    const regMatch = text.match(
      /(?:in accordance with|as required by|as specified in|as per|according to|complies with)\s+([^\.;]+)/i
    );
    
    if (regMatch && regMatch[1]) {
      return regMatch[1].trim();
    }
    
    // Look for specific regulation numbers
    const regNumberMatch = text.match(/(?:FAR|CFR|Part)\s+\d+(?:\.\d+)*/i);
    if (regNumberMatch) {
      return regNumberMatch[0];
    }
    
    return 'Applicable aviation regulations';
  }
  
  /**
   * Create session assessments
   * @param {Array<Object>} sessionContent Session content sections
   * @param {Object} content Full extracted content
   * @returns {Array<Object>} Session assessments
   */
  createSessionAssessments(sessionContent, content) {
    const assessments = [];
    
    // Create a general knowledge check
    assessments.push({
      id: `assessment-${uuidv4()}`,
      title: 'Knowledge Check Quiz',
      type: 'quiz',
      description: 'Brief quiz covering key concepts from the session',
      duration: 10,
      passingScore: 70
    });
    
    // Add compliance assessment if needed
    const hasComplianceContent = sessionContent.some(
      section => section.isCompliance || section.isSafetyCritical
    );
    
    if (hasComplianceContent) {
      assessments.push({
        id: `assessment-${uuidv4()}`,
        title: 'Compliance Verification',
        type: 'test',
        description: 'Assessment of understanding of critical regulatory requirements',
        duration: 15,
        passingScore: 80
      });
    }
    
    // Add practical assessment if needed
    const hasPracticalContent = sessionContent.some(
      section => section.isKeyProcedure || section.requiresHandsOn
    );
    
    if (hasPracticalContent) {
      assessments.push({
        id: `assessment-${uuidv4()}`,
        title: 'Practical Skills Evaluation',
        type: 'practical',
        description: 'Hands-on demonstration of required procedures and skills',
        duration: 20,
        passingScore: 80
      });
    }
    
    return assessments;
  }
  
  /**
   * Create compliance coverage information
   * @param {Array<Object>} sessionContent Session content sections
   * @param {Array<Object>} procedures All compliance procedures
   * @param {Array<Object>} assessments Session assessments
   * @returns {Array<Object>} Compliance coverage items
   */
  createComplianceCoverage(sessionContent, procedures, assessments) {
    const coverage = [];
    
    // Get IDs of all sections in this session
    const sectionIds = sessionContent.map(section => section.id);
    
    // Find procedures that are covered in this session
    for (const procedure of procedures) {
      // Check if procedure's source section is covered in this session
      const isInSession = sessionContent.some(
        section => section.title === procedure.title || 
                  section.id === procedure.id
      );
      
      // Get applicable assessment
      const assessmentId = assessments.find(
        a => a.type === 'test' || a.type === 'practical'
      )?.id;
      
      coverage.push({
        procedureId: procedure.id,
        title: procedure.title,
        covered: isInSession,
        assessmentId: isInSession ? assessmentId : undefined
      });
    }
    
    return coverage;
  }
  
  /**
   * Create instructor notes for the session
   * @param {Array<Object>} sessionContent Session content
   * @param {number} sessionIndex Session index
   * @param {number} totalSessions Total number of sessions
   * @returns {Array<string>} Instructor notes
   */
  createInstructorNotes(sessionContent, sessionIndex, totalSessions) {
    const notes = [];
    
    // General session guidance
    notes.push(
      `This is session ${sessionIndex} of ${totalSessions} in the training program.`
    );
    
    // Add notes about session flow
    notes.push(
      'Begin with a brief review of previous session content and verification of prerequisite knowledge.'
    );
    
    // Add notes about critical content
    const hasSafetyCritical = sessionContent.some(section => section.isSafetyCritical);
    if (hasSafetyCritical) {
      notes.push(
        'This session contains safety-critical content. Ensure all students demonstrate complete understanding before proceeding.'
      );
    }
    
    const hasCompliance = sessionContent.some(section => section.isCompliance);
    if (hasCompliance) {
      notes.push(
        'Regulatory compliance topics require thorough coverage. Reference current regulations and emphasize the importance of strict adherence.'
      );
    }
    
    // Add notes about practical components
    const hasPractical = sessionContent.some(section => section.requiresHandsOn);
    if (hasPractical) {
      notes.push(
        'Practical components should be demonstrated first, followed by supervised student practice. Provide immediate feedback during practice.'
      );
    }
    
    // Session timing
    notes.push(
      'Manage session time carefully to ensure all critical content is covered. If time is limited, prioritize safety and compliance topics.'
    );
    
    // Assessment guidance
    notes.push(
      'End the session with assessment activities to verify understanding. Document student performance, especially for compliance items.'
    );
    
    return notes;
  }
  
  /**
   * Create student preparation guidelines
   * @param {Array<Object>} sessionContent Session content
   * @returns {Array<string>} Student preparation items
   */
  createStudentPreparation(sessionContent) {
    const prep = [];
    
    // Basic preparation
    prep.push('Review materials from previous sessions if applicable');
    
    // Add specific preparation based on content
    const hasCompliance = sessionContent.some(section => section.isCompliance);
    if (hasCompliance) {
      prep.push('Familiarize yourself with basic regulatory requirements for aviation operations');
    }
    
    const hasPractical = sessionContent.some(section => section.requiresHandsOn);
    if (hasPractical) {
      prep.push('Come prepared for hands-on practice with appropriate attire and materials');
    }
    
    // Add key terms preparation
    prep.push('Be prepared to take notes and ask questions about unclear concepts');
    
    return prep;
  }
  
  /**
   * Create a session description
   * @param {Array<Object>} sessionContent Session content
   * @param {number} sessionIndex Session index
   * @param {number} totalSessions Total number of sessions
   * @returns {string} Session description
   */
  createSessionDescription(sessionContent, sessionIndex, totalSessions) {
    // Basic description template
    let description = `This is session ${sessionIndex} of ${totalSessions} in the training program, covering `;
    
    // List main topics (section titles)
    const topicTitles = sessionContent.map(section => section.title).slice(0, 3);
    
    if (topicTitles.length === 1) {
      description += topicTitles[0];
    } else if (topicTitles.length === 2) {
      description += `${topicTitles[0]} and ${topicTitles[1]}`;
    } else if (topicTitles.length > 2) {
      const lastTopic = topicTitles.pop();
      description += `${topicTitles.join(', ')}, and ${lastTopic}`;
    }
    
    // Add information about session type
    const hasCompliance = sessionContent.some(section => section.isCompliance);
    const hasPractical = sessionContent.some(section => section.requiresHandsOn);
    const hasSafety = sessionContent.some(section => section.isSafetyCritical);
    
    if (hasCompliance && hasPractical) {
      description += '. The session includes both regulatory compliance topics and hands-on practical exercises.';
    } else if (hasCompliance) {
      description += '. The session focuses on regulatory requirements and compliance procedures.';
    } else if (hasPractical) {
      description += '. The session emphasizes practical skills development through hands-on activities.';
    } else {
      description += '. The session provides theoretical knowledge and conceptual understanding.';
    }
    
    // Add safety note if applicable
    if (hasSafety) {
      description += ' Safety-critical content is emphasized throughout the session.';
    }
    
    return description;
  }
  
  /**
   * Create a student session plan from instructor plan
   * @param {Object} instructorPlan Instructor session plan
   * @returns {Object} Student session plan
   */
  createStudentSessionPlan(instructorPlan) {
    // Create a copy of the instructor plan
    const studentPlan = {
      ...instructorPlan,
      id: `session-student-${uuidv4()}`,
      planType: 'student'
    };
    
    // Remove instructor-specific information
    delete studentPlan.instructorNotes;
    
    // Modify activities to remove instructor notes
    studentPlan.activities = instructorPlan.activities.map(activity => {
      const { instructorNotes, ...studentActivity } = activity;
      return studentActivity;
    });
    
    // Include student preparation as part of description
    if (instructorPlan.studentPreparation && instructorPlan.studentPreparation.length > 0) {
      studentPlan.description += '\n\nPreparation: ' + 
        instructorPlan.studentPreparation.join('. ');
    }
    
    return studentPlan;
  }
}

// =====================================================================
// TRAINING FORM GENERATOR
// =====================================================================

/**
 * TrainingFormGenerator class handles the generation of training forms,
 * assessments, and compliance checklists based on extracted document content
 */
class TrainingFormGenerator {
  /**
   * Create a new TrainingFormGenerator
   */
  constructor() {
    this.assessmentQuestionTypes = [
      'multiple-choice',
      'true-false',
      'short-answer',
      'fill-in-blank'
    ];
  }
  
  /**
   * Generate training forms based on extracted content
   * @param {Object} content Extracted document content
   * @param {Object} options Form generation options
   * @returns {Promise<Array<Object>>} Array of training forms
   */
  async generateTrainingForms(content, options = {}) {
    try {
      // Set default options
      const defaultOptions = {
        generateAssessments: true,
        questionCount: 10,
        includePracticalTasks: true,
        includeSignoffs: true
      };
      
      const formOptions = { ...defaultOptions, ...options };
      
      const forms = [];
      
      // First, create assessment forms for compliance procedures
      if (formOptions.generateAssessments && content.complianceProcedures.length > 0) {
        const complianceForm = await this.createComplianceAssessment(
          content.complianceProcedures,
          formOptions
        );
        forms.push(complianceForm);
      }
      
      // Next, create general knowledge assessment forms
      const knowledgeForms = await this.createKnowledgeAssessments(content, formOptions);
      forms.push(...knowledgeForms);
      
      // Create practical task forms if applicable
      if (formOptions.includePracticalTasks) {
        const practicalSections = this.findPracticalSections(content.sections);
        
        if (practicalSections.length > 0) {
          const practicalForm = await this.createPracticalTaskAssessment(
            practicalSections,
            formOptions
          );
          forms.push(practicalForm);
        }
      }
      
      return forms;
    } catch (error) {
      console.error('Error generating training forms:', error);
      throw new Error('Failed to generate training forms');
    }
  }
  
  /**
   * Create a compliance assessment form
   * @param {Array<Object>} procedures Compliance procedures
   * @param {Object} options Form options
   * @returns {Promise<Object>} Training form
   */
  async createComplianceAssessment(procedures, options) {
    // Create form structure
    const form = {
      id: `form-compliance-${uuidv4()}`,
      title: 'Compliance Knowledge Assessment',
      description: 'This assessment evaluates understanding of key compliance procedures and requirements.',
      sectionReferences: procedures.map(p => p.section),
      questions: [],
    };
    
    // Add questions for each procedure
    for (const procedure of procedures) {
      // Skip low-criticality procedures if we have many
      if (procedures.length > 10 && procedure.criticalityLevel === 'low') {
        continue;
      }
      
      // Create multiple-choice question about procedure purpose
      const purposeQuestion = {
        id: `q-purpose-${uuidv4()}`,
        type: 'multiple-choice',
        question: `What is the primary purpose of the ${procedure.title} procedure?`,
        options: [
          procedure.description, // Correct answer
          this.generateIncorrectAnswer(procedure.description),
          this.generateIncorrectAnswer(procedure.description),
          this.generateIncorrectAnswer(procedure.description)
        ],
        correctAnswer: procedure.description,
        points: procedure.criticalityLevel === 'high' ? 5 : 3,
        complianceReference: procedure.regulation,
        explanation: `The primary purpose of ${procedure.title} is ${procedure.description}`
      };
      
      form.questions.push(purposeQuestion);
      
      // Create true/false question about a step
      if (procedure.steps.length > 0) {
        // Pick a random significant step
        const stepIndex = Math.floor(Math.random() * procedure.steps.length);
        const step = procedure.steps[stepIndex];
        
        // Decide if this will be true or false
        const isTrueQuestion = Math.random() > 0.5;
        
        let questionText;
        let correctAnswer;
        
        if (isTrueQuestion) {
          questionText = `True or False: When performing the ${procedure.title} procedure, you must ${step}`;
          correctAnswer = 'True';
        } else {
          questionText = `True or False: When performing the ${procedure.title} procedure, you must ${this.modifyStepForFalseQuestion(step)}`;
          correctAnswer = 'False';
        }
        
        const tfQuestion = {
          id: `q-tf-${uuidv4()}`,
          type: 'true-false',
          question: questionText,
          correctAnswer,
          points: procedure.criticalityLevel === 'high' ? 4 : 2,
          complianceReference: procedure.regulation
        };
        
        form.questions.push(tfQuestion);
      }
      
      // For high-criticality procedures, add a short-answer question
      if (procedure.criticalityLevel === 'high') {
        const saQuestion = {
          id: `q-sa-${uuidv4()}`,
          type: 'short-answer',
          question: `Explain the key safety considerations that must be addressed when performing the ${procedure.title} procedure.`,
          points: 5,
          complianceReference: procedure.regulation
        };
        
        form.questions.push(saQuestion);
      }
    }
    
    // Add practical tasks if appropriate
    const practicalTasks = [];
    
    // Select high-criticality procedures for practical assessment
    const criticalProcedures = procedures.filter(p => p.criticalityLevel === 'high');
    
    if (criticalProcedures.length > 0 && options.includePracticalTasks) {
      // Create practical tasks for up to 3 critical procedures
      for (const procedure of criticalProcedures.slice(0, 3)) {
        const task = {
          id: `task-${uuidv4()}`,
          description: `Demonstrate the ${procedure.title} procedure according to established guidelines`,
          criteria: procedure.assessmentCriteria || [],
          passingThreshold: 80,
          timeAllotted: 15 // 15 minutes
        };
        
        practicalTasks.push(task);
      }
    }
    
    if (practicalTasks.length > 0) {
      form.practicalTasks = practicalTasks;
    }
    
    // Add signoff requirements if needed
    const signoffRequirements = [];
    
    if (options.includeSignoffs) {
      // Check for procedures requiring signoff
      const signoffProcedures = procedures.filter(p => p.requiresSignoff);
      
      if (signoffProcedures.length > 0) {
        // Create instructor signoff
        signoffRequirements.push({
          title: 'Instructor Verification',
          role: 'Instructor',
          description: 'I certify that the trainee has demonstrated competence in all assessed compliance procedures.',
          regulatoryReference: signoffProcedures[0].regulation
        });
        
        // If high-criticality, add supervisor signoff
        if (signoffProcedures.some(p => p.criticalityLevel === 'high')) {
          signoffRequirements.push({
            title: 'Supervisor Approval',
            role: 'Supervisor',
            description: 'I verify that all high-criticality procedures have been properly demonstrated and assessed.',
            regulatoryReference: signoffProcedures
              .find(p => p.criticalityLevel === 'high')?.regulation
          });
        }
      }
    }
    
    if (signoffRequirements.length > 0) {
      form.signoffRequirements = signoffRequirements;
    }
    
    return form;
  }
  
  /**
   * Create knowledge assessment forms
   * @param {Object} content Extracted content
   * @param {Object} options Form options
   * @returns {Promise<Array<Object>>} Array of training forms
   */
  async createKnowledgeAssessments(content, options) {
    const forms = [];
    
    // Create a general knowledge assessment
    const generalForm = {
      id: `form-knowledge-${uuidv4()}`,
      title: 'General Knowledge Assessment',
      description: 'This assessment evaluates understanding of key concepts and terminology.',
      sectionReferences: content.sections.map(s => s.title),
      questions: [],
    };
    
    // Create questions based on key terms
    for (const term of content.keyTerms.slice(0, 5)) {
      const termQuestion = {
        id: `q-term-${uuidv4()}`,
        type: 'multiple-choice',
        question: `What is the correct definition of "${term.term}"?`,
        options: [
          term.definition, // Correct answer
          this.generateIncorrectDefinition(term),
          this.generateIncorrectDefinition(term),
          this.generateIncorrectDefinition(term)
        ],
        correctAnswer: term.definition,
        points: 2,
        explanation: `${term.term}: ${term.definition}`
      };
      
      generalForm.questions.push(termQuestion);
    }
    
    // Create questions based on section content
    for (const section of content.sections) {
      // Skip very short sections
      if (section.text.length < 200) continue;
      
      // Create question based on learning objectives if available
      if (section.learningObjectives.length > 0) {
        const objective = section.learningObjectives[0];
        
        // Extract key verbs from objective
        const verbs = ['identify', 'explain', 'describe', 'list', 'understand'];
        const verbMatch = objective.match(/\b(identify|explain|describe|list|understand)\b/i);
        const verb = verbMatch ? verbMatch[1].toLowerCase() : 'explain';
        
        // Create question based on verb
        let question;
        
        // Randomize question type
        const questionType = Math.random() > 0.5 ? 'short-answer' : 'multiple-choice';
        
        if (questionType === 'short-answer') {
          question = {
            id: `q-obj-${uuidv4()}`,
            type: 'short-answer',
            question: `${verb.charAt(0).toUpperCase() + verb.slice(1)} the key points about ${section.title}.`,
            points: 3
          };
        } else {
          // Create a question from the first paragraph
          const firstPara = this.extractFirstParagraph(section.text);
          
          // Turn it into a fill-in-the-blank by removing key words
          const words = firstPara.split(/\s+/);
          const keyWordIndices = [];
          
          // Find indices of potential key words (nouns, technical terms)
          words.forEach((word, index) => {
            // Skip first and last few words
            if (index < 3 || index > words.length - 3) return;
            
            // Look for capitalized words or words in keywords list
            if ((word.charAt(0) === word.charAt(0).toUpperCase() && 
                 word.charAt(0) !== word.charAt(0).toLowerCase()) ||
                section.keywords.includes(word.toLowerCase())) {
              keyWordIndices.push(index);
            }
          });
          
          if (keyWordIndices.length > 0) {
            // Pick a random key word to remove
            const removeIndex = keyWordIndices[Math.floor(Math.random() * keyWordIndices.length)];
            const removedWord = words[removeIndex];
            
            // Create options with one correct answer and three distractors
            const options = [
              removedWord,
              this.generateIncorrectWord(removedWord),
              this.generateIncorrectWord(removedWord),
              this.generateIncorrectWord(removedWord)
            ];
            
            // Replace the word with a blank in the question text
            words[removeIndex] = '________';
            
            question = {
              id: `q-fill-${uuidv4()}`,
              type: 'multiple-choice',
              question: `Fill in the blank: ${words.join(' ')}`,
              options,
              correctAnswer: removedWord,
              points: 2
            };
          } else {
            // Fallback if no suitable word found
            question = {
              id: `q-sec-${uuidv4()}`,
              type: 'short-answer',
              question: `Describe the main points covered in the section on ${section.title}.`,
              points: 3
            };
          }
        }
        
        generalForm.questions.push(question);
      }
      
      // Only add a few questions total
      if (generalForm.questions.length >= options.questionCount) break;
    }
    
    forms.push(generalForm);
    
    return forms;
  }
  
  /**
   * Find sections that require practical tasks
   * @param {Array<Object>} sections Content sections
   * @returns {Array<Object>} Practical sections
   */
  findPracticalSections(sections) {
    const practical = [];
    
    const searchSection = (section) => {
      if (section.requiresHandsOn || section.isKeyProcedure) {
        practical.push(section);
      }
      
      // Search subsections
      section.subsections.forEach(searchSection);
    };
    
    // Search all top-level sections
    sections.forEach(searchSection);
    
    return practical;
  }
  
  /**
   * Create practical task assessment
   * @param {Array<Object>} sections Practical sections
   * @param {Object} options Form options
   * @returns {Promise<Object>} Training form
   */
  async createPracticalTaskAssessment(sections, options) {
    // Create form structure
    const form = {
      id: `form-practical-${uuidv4()}`,
      title: 'Practical Skills Assessment',
      description: 'This assessment evaluates hands-on skills and practical application of procedures.',
      sectionReferences: sections.map(s => s.title),
      questions: [],
      practicalTasks: [],
    };
    
    // Create practical tasks for each section
    for (const section of sections) {
      const task = {
        id: `task-${uuidv4()}`,
        description: `Demonstrate proficiency in ${section.title}`,
        criteria: this.generatePracticalCriteria(section),
        passingThreshold: 70,
        timeAllotted: 20 // 20 minutes per task
      };
      
      // Add equipment needed if mentioned in the section
      const equipmentMatch = section.text.match(/(?:equipment|tools|materials) (?:needed|required|necessary):\s*([^.;]+)/i);
      if (equipmentMatch && equipmentMatch[1]) {
        task.equipmentNeeded = equipmentMatch[1]
          .split(/,|\band\b/)
          .map(item => item.trim())
          .filter(item => item.length > 0);
      }
      
      form.practicalTasks.push(task);
    }
    
    // Add some written questions about practical application
    if (sections.length > 0) {
      for (const section of sections.slice(0, 3)) {
        const question = {
          id: `q-practical-${uuidv4()}`,
          type: 'short-answer',
          question: `Explain the key points to remember when performing ${section.title}. What common errors should be avoided?`,
          points: 5
        };
        
        form.questions.push(question);
      }
    }
    
    // Add signoff requirements if options include them
    if (options.includeSignoffs) {
      const signoffRequirements = [
        {
          title: 'Practical Skills Verification',
          role: 'Instructor',
          description: 'I certify that the trainee has demonstrated the required practical skills to a satisfactory standard.',
        }
      ];
      
      form.signoffRequirements = signoffRequirements;
    }
    
    return form;
  }
  
  /**
   * Generate criteria for practical assessment
   * @param {Object} section Content section
   * @returns {Array<string>} Assessment criteria
   */
  generatePracticalCriteria(section) {
    const criteria = [];
    
    // Look for specific instructions or steps
    const steps = this.extractProcedureSteps(section.text);
    
    if (steps.length > 0) {
      // Convert key steps to criteria
      for (const step of steps.slice(0, 5)) { // Limit to 5 steps
        criteria.push(`Correctly ${step.toLowerCase()}`);
      }
    }
    
    // If no specific steps found, create general criteria
    if (criteria.length < 3) {
      // General criteria based on section type
      criteria.push('Demonstrates proper technique and procedure');
      
      if (section.isSafetyCritical) {
        criteria.push('Follows all safety protocols and precautions');
      }
      
      if (section.isCompliance) {
        criteria.push('Complies with all regulatory requirements');
      }
      
      criteria.push('Performs task efficiently and correctly');
      criteria.push('Demonstrates confidence and competence');
    }
    
    return criteria;
  }
  
  /**
   * Extract procedure steps from text
   * @param {string} text Section text
   * @returns {Array<string>} Procedure steps
   */
  extractProcedureSteps(text) {
    const steps = [];
    
    // Look for numbered or bulleted lists
    const listPatterns = [
      /(?:^|\n)\s*(\d+)[\.\)]\s+([^\n]+)/g, // Numbered list: "1. Step one"
      /(?:^|\n)\s*([a-z])[\.\)]\s+([^\n]+)/g, // Letter list: "a. Step one"
      /(?:^|\n)\s*[\*\-â€¢]\s+([^\n]+)/g // Bullet list: "â€¢ Step one"
    ];
    
    for (const pattern of listPatterns) {
      let match;
      while ((match = pattern.exec(text)) !== null) {
        // Different handling based on pattern
        if (pattern.source.includes('\\*')) {
          // Bullet pattern
          steps.push(match[1].trim());
        } else {
          // Numbered or letter pattern
          steps.push(match[2].trim());
        }
      }
      
      // If steps found, return them
      if (steps.length > 0) return steps;
    }
    
    // If no list format found, try to split by sentences
    if (steps.length === 0) {
      const sentences = text.match(/[^.!?]+[.!?]+/g) || [];
      
      // Filter sentences that look like instructions
      const instructionSentences = sentences.filter(sentence => 
        /(?:must|shall|should|ensure|verify|check|perform|complete|review)/i.test(sentence)
      );
      
      if (instructionSentences.length > 0) {
        // Limit to a reasonable number of steps
        return instructionSentences.slice(0, 10).map(s => s.trim());
      }
    }
    
    return steps;
  }
  
  /**
   * Extract the first paragraph from text
   * @param {string} text Section text
   * @returns {string} First paragraph
   */
  extractFirstParagraph(text) {
    // Try to find the first non-empty paragraph
    const paragraphs = text.split(/\n\s*\n/);
    
    for (const paragraph of paragraphs) {
      const trimmed = paragraph.trim();
      if (trimmed && trimmed.length > 20) {
        return trimmed;
      }
    }
    
    // If no good paragraph found, return the first sentence
    const sentences = text.match(/[^.!?]+[.!?]+/g) || [];
    return sentences.length > 0 ? sentences[0].trim() : text.slice(0, 100).trim();
  }
  
  /**
   * Generate an incorrect answer for multiple choice questions
   * @param {string} correctAnswer The correct answer to avoid
   * @returns {string} Incorrect answer
   */
  generateIncorrectAnswer(correctAnswer) {
    // Create variations of the correct answer to serve as distractors
    const variations = [
      'This procedure is not related to aviation operations.',
      'This is an optional guideline with no regulatory basis.',
      'This procedure is only required during emergency situations.',
      'This is a deprecated procedure that has been replaced by newer standards.',
      'This procedure applies only to maintenance personnel, not flight operations.',
      'This is a recommendation, not a mandatory requirement.',
      'This procedure is specific to helicopter operations only.',
      'This refers to a training exercise, not an operational requirement.'
    ];
    
    // Pick a random variation
    return variations[Math.floor(Math.random() * variations.length)];
  }
  
  /**
   * Generate an incorrect definition for term-based questions
   * @param {Object} term The term with the correct definition
   * @returns {string} Incorrect definition
   */
  generateIncorrectDefinition(term) {
    // Create plausible but incorrect definitions
    const variations = [
      `A common misconception about ${term.term}, but not the actual meaning.`,
      `A related concept often confused with ${term.term}, but incorrect in this context.`,
      `A historical definition of ${term.term} that is no longer accurate.`,
      `A definition that applies to a different aviation term, not ${term.term}.`
    ];
    
    // Pick a random variation
    return variations[Math.floor(Math.random() * variations.length)];
  }
  
  /**
   * Generate an incorrect word for fill-in-blank questions
   * @param {string} correctWord The correct word to avoid
   * @returns {string} Incorrect word
   */
  generateIncorrectWord(correctWord) {
    // If it's a number, change it slightly
    if (/^\d+$/.test(correctWord)) {
      const num = parseInt(correctWord, 10);
      return (num + Math.floor(Math.random() * 10) + 1).toString();
    }
    
    // Substitute with a plausible alternative
    const aviationRelatedWords = [
      'altitude', 'approach', 'checklist', 'clearance', 'descent',
      'heading', 'procedure', 'runway', 'taxiway', 'threshold',
      'visibility', 'waypoint', 'altitude', 'ceiling', 'departure'
    ];
    
    // Pick a word that's different from the correct one
    let alternative;
    do {
      alternative = aviationRelatedWords[Math.floor(Math.random() * aviationRelatedWords.length)];
    } while (alternative.toLowerCase() === correctWord.toLowerCase());
    
    return alternative;
  }
  
  /**
   * Modify a step to create a false statement for true/false questions
   * @param {string} step Correct step
   * @returns {string} Modified incorrect step
   */
  modifyStepForFalseQuestion(step) {
    // Common modifications to create false statements
    const modifications = [
      // Change a positive to a negative
      (s) => s.replace(/must|shall|should|always/, 'never'),
      // Change a negative to a positive
      (s) => s.replace(/never|avoid|do not/, 'always'),
      // Change a number
      (s) => {
        const numMatch = s.match(/\b(\d+)\b/);
        if (numMatch) {
          const num = parseInt(numMatch[1], 10);
          const newNum = num * 2; // Double it to make it clearly wrong
          return s.replace(numMatch[0], newNum.toString());
        }
        return `skip ${s}`; // Fallback
      },
      // Reverse the meaning
      (s) => `do the opposite of what is normally required when you ${s}`
    ];
    
    // Pick a random modification
    const modifier = modifications[Math.floor(Math.random() * modifications.length)];
    return modifier(step);
  }
}

// =====================================================================
// FRONTEND IMPLEMENTATION - REACT COMPONENTS
// =====================================================================

/**
 * Frontend React components for the Aviation Training Document Management System
 * 
 * These components provide the user interface for:
 * - Document upload and processing
 * - Session plan viewing and editing
 * - Training form creation and customization
 * - Material export and download
 */

/**
 * Component: App.jsx - Main application component
 */
const App = () => {
  return `
import React, { useState } from 'react';
import { BrowserRouter as Router, Route, Switch, Link } from 'react-router-dom';
import { Container, AppBar, Toolbar, Typography, Button, Box } from '@material-ui/core';
import Dashboard from './components/Dashboard';
import DocumentUpload from './components/DocumentUpload';
import DocumentView from './components/DocumentView';
import SessionPlanList from './components/SessionPlanList';
import SessionPlanEditor from './components/SessionPlanEditor';
import TrainingFormList from './components/TrainingFormList';
import TrainingFormEditor from './components/TrainingFormEditor';
import ProcessingStatus from './components/ProcessingStatus';

function App() {
  return (
    <Router>
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6" style={{ flexGrow: 1 }}>
            Aviation Training Document Management
          </Typography>
          <Button color="inherit" component={Link} to="/">Dashboard</Button>
          <Button color="inherit" component={Link} to="/upload">Upload</Button>
        </Toolbar>
      </AppBar>
      
      <Container maxWidth="lg">
        <Box my={4}>
          <Switch>
            <Route exact path="/" component={Dashboard} />
            <Route path="/upload" component={DocumentUpload} />
            <Route path="/documents/:id" component={DocumentView} />
            <Route path="/documents/:id/sessions" component={SessionPlanList} />
            <Route path="/session-plans/:id/edit" component={SessionPlanEditor} />
            <Route path="/documents/:id/forms" component={TrainingFormList} />
            <Route path="/training-forms/:id/edit" component={TrainingFormEditor} />
            <Route path="/processing/:id" component={ProcessingStatus} />
          </Switch>
        </Box>
      </Container>
    </Router>
  );
}

export default App;
`;
}

/**
 * Component: Dashboard.jsx - Dashboard for document management
 */
const Dashboard = () => {
  return `
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { 
  Typography, 
  Paper, 
  Grid, 
  Button, 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  CircularProgress
} from '@material-ui/core';
import { formatDistanceToNow } from 'date-fns';
import axios from 'axios';

function Dashboard() {
  const [documents, setDocuments] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // Fetch documents on component mount
    fetchDocuments();
  }, []);

  const fetchDocuments = async () => {
    try {
      setLoading(true);
      const response = await axios.get('/api/documents');
      setDocuments(response.data);
      setLoading(false);
    } catch (err) {
      console.error('Error fetching documents:', err);
      setError('Failed to load documents. Please try again later.');
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', marginTop: 100 }}>
        <CircularProgress />
      </div>
    );
  }

  if (error) {
    return (
      <Paper style={{ padding: 20, marginTop: 20 }}>
        <Typography color="error">{error}</Typography>
        <Button variant="contained" color="primary" onClick={fetchDocuments} style={{ marginTop: 10 }}>
          Retry
        </Button>
      </Paper>
    );
  }

  return (
    <div>
      <Grid container spacing={3} alignItems="center" style={{ marginBottom: 20 }}>
        <Grid item xs>
          <Typography variant="h4">Training Documents</Typography>
        </Grid>
        <Grid item>
          <Button 
            variant="contained" 
            color="primary" 
            component={Link} 
            to="/upload"
          >
            Upload New Document
          </Button>
        </Grid>
      </Grid>

      {documents.length === 0 ? (
        <Paper style={{ padding: 20, textAlign: 'center' }}>
          <Typography variant="body1">
            No documents found. Upload a new document to get started.
          </Typography>
          <Button 
            variant="contained" 
            color="primary" 
            component={Link} 
            to="/upload"
            style={{ marginTop: 20 }}
          >
            Upload Document
          </Button>
        </Paper>
      ) : (
        <TableContainer component={Paper}>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell><strong>Document Title</strong></TableCell>
                <TableCell><strong>Pages</strong></TableCell>
                <TableCell><strong>Uploaded</strong></TableCell>
                <TableCell><strong>Status</strong></TableCell>
                <TableCell><strong>Actions</strong></TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {documents.map((doc) => (
                <TableRow key={doc._id}>
                  <TableCell>
                    <Link to={'/documents/' + doc._id}>
                      {doc.metadata?.title || doc.originalFilename}
                    </Link>
                  </TableCell>
                  <TableCell>{doc.metadata?.totalPages || '-'}</TableCell>
                  <TableCell>
                    {doc.uploadDate ? formatDistanceToNow(new Date(doc.uploadDate), { addSuffix: true }) : '-'}
                  </TableCell>
                  <TableCell>
                    {doc.processingStatus === 'completed' ? (
                      <span style={{ color: 'green' }}>Completed</span>
                    ) : doc.processingStatus === 'failed' ? (
                      <span style={{ color: 'red' }}>Failed</span>
                    ) : doc.processingStatus === 'processing' ? (
                      <Link to={'/processing/' + doc._id}>
                        <span style={{ color: 'blue' }}>Processing...</span>
                      </Link>
                    ) : (
                      <span style={{ color: 'orange' }}>Pending</span>
                    )}
                  </TableCell>
                  <TableCell>
                    {doc.processingStatus === 'completed' && (
                      <>
                        <Button 
                          variant="outlined" 
                          size="small" 
                          component={Link} 
                          to={'/documents/' + doc._id + '/sessions'}
                          style={{ marginRight: 8 }}
                        >
                          Session Plans
                        </Button>
                        <Button 
                          variant="outlined" 
                          size="small" 
                          component={Link} 
                          to={'/documents/' + doc._id + '/forms'}
                        >
                          Training Forms
                        </Button>
                      </>
                    )}
                    {doc.processingStatus === 'processing' && (
                      <Button 
                        variant="outlined" 
                        size="small" 
                        component={Link} 
                        to={'/processing/' + doc._id}
                      >
                        View Progress
                      </Button>
                    )}
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      )}
    </div>
  );
}

export default Dashboard;
`;
}

/**
 * Component: DocumentUpload.jsx - File upload component
 */
const DocumentUpload = () => {
  return `
import React, { useState } from 'react';
import { useHistory } from 'react-router-dom';
import { 
  Typography, 
  Paper, 
  Button, 
  Box, 
  CircularProgress, 
  Stepper, 
  Step, 
  StepLabel,
  FormControl,
  FormLabel,
  FormGroup,
  FormControlLabel,
  Checkbox,
  TextField,
  MenuItem,
  Select,
  InputLabel
} from '@material-ui/core';
import { Alert } from '@material-ui/lab';
import CloudUploadIcon from '@material-ui/icons/CloudUpload';
import axios from 'axios';

function DocumentUpload() {
  const history = useHistory();
  const [activeStep, setActiveStep] = useState(0);
  const [selectedFile, setSelectedFile] = useState(null);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [uploading, setUploading] = useState(false);
  const [error, setError] = useState(null);
  const [processingOptions, setProcessingOptions] = useState({
    extractHeadings: true,
    identifyCompliance: true,
    identifyKeyTerms: true,
    generateAssessments: true,
    sessionDuration: 120,
    maxSessionCount: 5,
    includeImages: true,
    studentLevel: 'intermediate',
    sessionFormat: 'classroom'
  });

  const handleFileChange = (event) => {
    const file = event.target.files[0];
    setSelectedFile(file);
  };

  const handleNext = () => {
    setActiveStep((prevStep) => prevStep + 1);
  };

  const handleBack = () => {
    setActiveStep((prevStep) => prevStep - 1);
  };

  const handleOptionChange = (e) => {
    const { name, value, checked, type } = e.target;
    setProcessingOptions(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const handleNumberChange = (e) => {
    const { name, value } = e.target;
    setProcessingOptions(prev => ({
      ...prev,
      [name]: parseInt(value, 10)
    }));
  };

  const handleSubmit = async () => {
    if (!selectedFile) {
      setError('Please select a file to upload');
      return;
    }

    setUploading(true);
    setUploadProgress(0);
    setError(null);

    // Create form data
    const formData = new FormData();
    formData.append('document', selectedFile);
    formData.append('options', JSON.stringify(processingOptions));

    try {
      // Upload the file
      const response = await axios.post('/api/documents/upload', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        },
        onUploadProgress: (progressEvent) => {
          const percentCompleted = Math.round(
            (progressEvent.loaded * 100) / progressEvent.total
          );
          setUploadProgress(percentCompleted);
        }
      });

      setUploading(false);
      
      // Redirect to processing status page
      history.push('/processing/' + response.data.documentId);
    } catch (err) {
      console.error('Upload error:', err);
      setError(err.response?.data?.error || 'Failed to upload document');
      setUploading(false);
    }
  };

  const steps = ['Select Document', 'Configure Options', 'Upload'];

  return (
    <div>
      <Typography variant="h4" gutterBottom>
        Upload Training Document
      </Typography>

      <Paper style={{ padding: 20, marginBottom: 20 }}>
        <Stepper activeStep={activeStep} alternativeLabel>
          {steps.map((label) => (
            <Step key={label}>
              <StepLabel>{label}</StepLabel>
            </Step>
          ))}
        </Stepper>

        <Box mt={4}>
          {activeStep === 0 && (
            <>
              <Typography variant="h6" gutterBottom>
                Select a Training Document to Upload
              </Typography>
              <Typography variant="body2" color="textSecondary" paragraph>
                Upload an aviation training manual, procedure guide, or regulatory document (PDF or DOCX format). 
                The system will process the document to extract structured content, identify compliance procedures, 
                and generate training materials.
              </Typography>
              
              <Box 
                border={1} 
                borderRadius={4} 
                borderColor="grey.400" 
                p={3} 
                textAlign="center"
                mb={3}
              >
                <input
                  accept=".pdf,.docx"
                  style={{ display: 'none' }}
                  id="upload-document-button"
                  type="file"
                  onChange={handleFileChange}
                />
                <label htmlFor="upload-document-button">
                  <Button
                    variant="contained"
                    color="primary"
                    component="span"
                    startIcon={<CloudUploadIcon />}
                  >
                    Select Document
                  </Button>
                </label>
                
                {selectedFile && (
                  <Box mt={2}>
                    <Typography>
                      Selected file: <strong>{selectedFile.name}</strong> ({(selectedFile.size / 1024 / 1024).toFixed(2)} MB)
                    </Typography>
                  </Box>
                )}
              </Box>
            </>
          )}

          {activeStep === 1 && (
            <>
              <Typography variant="h6" gutterBottom>
                Configure Processing Options
              </Typography>
              
              <FormControl component="fieldset" style={{ marginBottom: 20 }}>
                <FormLabel component="legend">Content Extraction</FormLabel>
                <FormGroup>
                  <FormControlLabel
                    control={
                      <Checkbox 
                        checked={processingOptions.extractHeadings} 
                        onChange={handleOptionChange}
                        name="extractHeadings"
                      />
                    }
                    label="Extract document structure and headings"
                  />
                  <FormControlLabel
                    control={
                      <Checkbox 
                        checked={processingOptions.identifyCompliance} 
                        onChange={handleOptionChange}
                        name="identifyCompliance"
                      />
                    }
                    label="Identify regulatory compliance content"
                  />
                  <FormControlLabel
                    control={
                      <Checkbox 
                        checked={processingOptions.identifyKeyTerms} 
                        onChange={handleOptionChange}
                        name="identifyKeyTerms"
                      />
                    }
                    label="Extract key terms and definitions"
                  />
                  <FormControlLabel
                    control={
                      <Checkbox 
                        checked={processingOptions.generateAssessments} 
                        onChange={handleOptionChange}
                        name="generateAssessments"
                      />
                    }
                    label="Generate assessment questions"
                  />
                  <FormControlLabel
                    control={
                      <Checkbox 
                        checked={processingOptions.includeImages} 
                        onChange={handleOptionChange}
                        name="includeImages"
                      />
                    }
                    label="Include images from document (if available)"
                  />
                </FormGroup>
              </FormControl>
              
              <FormControl fullWidth margin="normal">
                <InputLabel>Session Format</InputLabel>
                <Select
                  name="sessionFormat"
                  value={processingOptions.sessionFormat}
                  onChange={handleOptionChange}
                >
                  <MenuItem value="classroom">Classroom</MenuItem>
                  <MenuItem value="simulator">Simulator</MenuItem>
                  <MenuItem value="online">Online</MenuItem>
                  <MenuItem value="blended">Blended</MenuItem>
                </Select>
              </FormControl>
              
              <FormControl fullWidth margin="normal">
                <InputLabel>Student Experience Level</InputLabel>
                <Select
                  name="studentLevel"
                  value={processingOptions.studentLevel}
                  onChange={handleOptionChange}
                >
                  <MenuItem value="beginner">Beginner</MenuItem>
                  <MenuItem value="intermediate">Intermediate</MenuItem>
                  <MenuItem value="advanced">Advanced</MenuItem>
                </Select>
              </FormControl>
              
              <TextField
                label="Session Duration (minutes)"
                type="number"
                name="sessionDuration"
                value={processingOptions.sessionDuration}
                onChange={handleNumberChange}
                fullWidth
                margin="normal"
                inputProps={{ min: 30, max: 480 }}
              />
              
              <TextField
                label="Maximum Number of Sessions"
                type="number"
                name="maxSessionCount"
                value={processingOptions.maxSessionCount}
                onChange={handleNumberChange}
                fullWidth
                margin="normal"
                inputProps={{ min: 1, max: 20 }}
              />
            </>
          )}

          {activeStep === 2 && (
            <>
              <Typography variant="h6" gutterBottom>
                Upload and Process Document
              </Typography>
              
              <Box my={2}>
                <Typography variant="body1">
                  <strong>File:</strong> {selectedFile?.name}
                </Typography>
                <Typography variant="body2" color="textSecondary">
                  The document will be uploaded and processed according to your settings. 
                  This may take several minutes depending on the document size and complexity.
                </Typography>
              </Box>
              
              {error && (
                <Alert severity="error" style={{ marginTop: 16, marginBottom: 16 }}>
                  {error}
                </Alert>
              )}
              
              {uploading && (
                <Box textAlign="center" my={4}>
                  <CircularProgress variant="determinate" value={uploadProgress} />
                  <Typography variant="body2" style={{ marginTop: 8 }}>
                    {uploadProgress === 100 ? 'Processing document...' : `Uploading: ${uploadProgress}%`}
                  </Typography>
                </Box>
              )}
            </>
          )}
        </Box>

        <Box mt={4} display="flex" justifyContent="space-between">
          <Button
            disabled={activeStep === 0 || uploading}
            onClick={handleBack}
          >
            Back
          </Button>
          
          <div>
            {activeStep === steps.length - 1 ? (
              <Button
                variant="contained"
                color="primary"
                onClick={handleSubmit}
                disabled={!selectedFile || uploading}
              >
                {uploading ? 'Uploading...' : 'Upload & Process'}
              </Button>
            ) : (
              <Button
                variant="contained"
                color="primary"
                onClick={handleNext}
                disabled={activeStep === 0 && !selectedFile}
              >
                Next
              </Button>
            )}
          </div>
        </Box>
      </Paper>
    </div>
  );
}

export default DocumentUpload;
`;
}

/**
 * Component: ProcessingStatus.jsx - Document processing status viewer
 */
const ProcessingStatus = () => {
  return `
import React, { useState, useEffect } from 'react';
import { useParams, useHistory } from 'react-router-dom';
import { 
  Typography, 
  Paper, 
  Button, 
  Box, 
  CircularProgress,
  Stepper,
  Step,
  StepLabel,
  StepContent
} from '@material-ui/core';
import { Alert } from '@material-ui/lab';
import axios from 'axios';

function ProcessingStatus() {
  const { id } = useParams();
  const history = useHistory();
  const [status, setStatus] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // Fetch status on mount
    fetchStatus();
    
    // Set up polling
    const interval = setInterval(fetchStatus, 3000);
    
    // Clean up interval on unmount
    return () => clearInterval(interval);
  }, [id]);

  const fetchStatus = async () => {
    try {
      const response = await axios.get(\`/api/documents/\${id}/status\`);
      setStatus(response.data);
      setLoading(false);
      
      // If processing is completed or failed, stop polling
      if (response.data.status === 'completed' || response.data.status === 'failed') {
        clearInterval(interval);
      }
    } catch (err) {
      console.error('Error fetching status:', err);
      setError('Failed to get processing status');
      setLoading(false);
    }
  };

  const handleViewDocument = () => {
    history.push(\`/documents/\${id}\`);
  };

  const handleReturnToDashboard = () => {
    history.push('/');
  };

  const getActiveStep = () => {
    switch (status?.progress?.stage) {
      case 'upload':
        return 0;
      case 'extraction':
        return 1;
      case 'analysis':
        return 2;
      case 'generation':
        return 3;
      case 'complete':
        return 4;
      default:
        return 0;
    }
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" my={4}>
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Paper style={{ padding: 20 }}>
        <Alert severity="error">{error}</Alert>
        <Box mt={2}>
          <Button variant="contained" onClick={handleReturnToDashboard}>
            Return to Dashboard
          </Button>
        </Box>
      </Paper>
    );
  }

  return (
    <div>
      <Typography variant="h4" gutterBottom>
        Document Processing Status
      </Typography>
      
      <Paper style={{ padding: 20, marginBottom: 20 }}>
        <Box mb={3}>
          <Typography variant="h6">
            Status: {' '}
            {status.status === 'completed' ? (
              <span style={{ color: 'green' }}>Completed</span>
            ) : status.status === 'failed' ? (
              <span style={{ color: 'red' }}>Failed</span>
            ) : status.status === 'processing' ? (
              <span style={{ color: 'blue' }}>Processing</span>
            ) : (
              <span style={{ color: 'orange' }}>Pending</span>
            )}
          </Typography>
        </Box>
        
        {status.status === 'failed' && (
          <Alert severity="error" style={{ marginBottom: 20 }}>
            {status.progress?.message || 'Processing failed'}
          </Alert>
        )}
        
        <Stepper activeStep={getActiveStep()} orientation="vertical">
          <Step>
            <StepLabel>Document Upload</StepLabel>
            <StepContent>
              <Typography>Receiving the document file and preparing for processing.</Typography>
            </StepContent>
          </Step>
          
          <Step>
            <StepLabel>Content Extraction</StepLabel>
            <StepContent>
              <Typography>
                Extracting text content from the document and identifying document structure.
              </Typography>
              {status.progress?.stage === 'extraction' && (
                <Box mt={2} display="flex" alignItems="center">
                  <CircularProgress 
                    variant="determinate" 
                    value={status.progress.percent} 
                    size={24} 
                    style={{ marginRight: 8 }} 
                  />
                  <Typography variant="body2">
                    {status.progress.message}
                  </Typography>
                </Box>
              )}
            </StepContent>
          </Step>
          
          <Step>
            <StepLabel>Content Analysis</StepLabel>
            <StepContent>
              <Typography>
                Analyzing document content, identifying compliance procedures, extracting key terms, 
                and assessing learning objectives.
              </Typography>
              {status.progress?.stage === 'analysis' && (
                <Box mt={2} display="flex" alignItems="center">
                  <CircularProgress 
                    variant="determinate" 
                    value={status.progress.percent} 
                    size={24} 
                    style={{ marginRight: 8 }} 
                  />
                  <Typography variant="body2">
                    {status.progress.message}
                  </Typography>
                </Box>
              )}
            </StepContent>
          </Step>
          
          <Step>
            <StepLabel>Material Generation</StepLabel>
            <StepContent>
              <Typography>
                Generating training session plans, assessment forms, and reference materials
                based on the analyzed content.
              </Typography>
              {status.progress?.stage === 'generation' && (
                <Box mt={2} display="flex" alignItems="center">
                  <CircularProgress 
                    variant="determinate" 
                    value={status.progress.percent} 
                    size={24} 
                    style={{ marginRight: 8 }} 
                  />
                  <Typography variant="body2">
                    {status.progress.message}
                  </Typography>
                </Box>
              )}
            </StepContent>
          </Step>
          
          <Step>
            <StepLabel>Complete</StepLabel>
            <StepContent>
              <Typography>
                Document processing completed successfully. You can now view the document and 
                generate training materials.
              </Typography>
            </StepContent>
          </Step>
        </Stepper>
        
        <Box mt={4}>
          {status.status === 'completed' ? (
            <Button variant="contained" color="primary" onClick={handleViewDocument}>
              View Document
            </Button>
          ) : (
            <Button variant="outlined" onClick={handleReturnToDashboard}>
              Return to Dashboard
            </Button>
          )}
        </Box>
      </Paper>
    </div>
  );
}

export default ProcessingStatus;
`;
}

/**
 * Component: DocumentView.jsx - Document viewer component
 */
const DocumentView = () => {
  return `
import React, { useState, useEffect } from 'react';
import { useParams, Link } from 'react-router-dom';
import { 
  Typography, 
  Paper, 
  Tabs, 
  Tab, 
  Box, 
  Button, 
  List, 
  ListItem, 
  ListItemText, 
  ListItemIcon,
  Divider,
  Chip,
  CircularProgress,
  Accordion,
  AccordionSummary,
  AccordionDetails
} from '@material-ui/core';
import { Alert } from '@material-ui/lab';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import DescriptionIcon from '@material-ui/icons/Description';
import AssignmentIcon from '@material-ui/icons/Assignment';
import ListAltIcon from '@material-ui/icons/ListAlt';
import VerifiedUserIcon from '@material-ui/icons/VerifiedUser';
import SchoolIcon from '@material-ui/icons/School';
import axios from 'axios';

function DocumentView() {
  const { id } = useParams();
  const [document, setDocument] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [tabValue, setTabValue] = useState(0);

  useEffect(() => {
    // Fetch document data
    fetchDocument();
  }, [id]);

  const fetchDocument = async () => {
    try {
      const response = await axios.get(\`/api/documents/\${id}\`);
      setDocument(response.data);
      setLoading(false);
    } catch (err) {
      console.error('Error fetching document:', err);
      setError('Failed to load document');
      setLoading(false);
    }
  };

  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  const handleGenerateSessionPlans = async () => {
    try {
      await axios.post(\`/api/documents/\${id}/session-plans\`);
      // No need to wait, redirect to session plans page
      window.location.href = \`/documents/\${id}/sessions\`;
    } catch (err) {
      console.error('Error generating session plans:', err);
      setError('Failed to generate session plans');
    }
  };

  const handleGenerateTrainingForms = async () => {
    try {
      await axios.post(\`/api/documents/\${id}/training-forms\`);
      // No need to wait, redirect to training forms page
      window.location.href = \`/documents/\${id}/forms\`;
    } catch (err) {
      console.error('Error generating training forms:', err);
      setError('Failed to generate training forms');
    }
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" my={4}>
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Paper style={{ padding: 20 }}>
        <Alert severity="error">{error}</Alert>
        <Box mt={2}>
          <Button variant="contained" component={Link} to="/">
            Return to Dashboard
          </Button>
        </Box>
      </Paper>
    );
  }

  if (!document) {
    return (
      <Paper style={{ padding: 20 }}>
        <Alert severity="warning">Document not found</Alert>
        <Box mt={2}>
          <Button variant="contained" component={Link} to="/">
            Return to Dashboard
          </Button>
        </Box>
      </Paper>
    );
  }

  return (
    <div>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Typography variant="h4">
          {document.metadata?.title || document.originalFilename}
        </Typography>
        
        <Box>
          <Button 
            variant="contained" 
            color="primary" 
            onClick={handleGenerateSessionPlans}
            style={{ marginRight: 8 }}
          >
            Generate Session Plans
          </Button>
          <Button 
            variant="contained" 
            color="primary" 
            onClick={handleGenerateTrainingForms}
          >
            Generate Training Forms
          </Button>
        </Box>
      </Box>
      
      <Paper style={{ marginBottom: 20 }}>
        <Tabs 
          value={tabValue} 
          onChange={handleTabChange} 
          indicatorColor="primary"
          textColor="primary"
        >
          <Tab label="Overview" />
          <Tab label="Document Structure" />
          <Tab label="Key Terms" />
          <Tab label="Compliance Procedures" />
        </Tabs>
        
        <Box p={3}>
          {tabValue === 0 && (
            <Box>
              <Typography variant="h6" gutterBottom>Document Information</Typography>
              
              <Box display="flex" flexWrap="wrap">
                <Box mr={4} mb={2}>
                  <Typography variant="body2" color="textSecondary">File Name</Typography>
                  <Typography variant="body1">{document.originalFilename}</Typography>
                </Box>
                
                <Box mr={4} mb={2}>
                  <Typography variant="body2" color="textSecondary">Pages</Typography>
                  <Typography variant="body1">{document.metadata?.totalPages || 'Unknown'}</Typography>
                </Box>
                
                <Box mr={4} mb={2}>
                  <Typography variant="body2" color="textSecondary">Author</Typography>
                  <Typography variant="body1">{document.metadata?.author || 'Not specified'}</Typography>
                </Box>
                
                <Box mr={4} mb={2}>
                  <Typography variant="body2" color="textSecondary">Publication Date</Typography>
                  <Typography variant="body1">{document.metadata?.publishDate || 'Not specified'}</Typography>
                </Box>
              </Box>
              
              <Box mt={4}>
                <Typography variant="h6" gutterBottom>Available Actions</Typography>
                
                <List>
                  <ListItem button component={Link} to={\`/documents/\${id}/sessions\`}>
                    <ListItemIcon>
                      <AssignmentIcon />
                    </ListItemIcon>
                    <ListItemText 
                      primary="Session Plans" 
                      secondary="View and edit training session plans generated from this document" 
                    />
                  </ListItem>
                  
                  <ListItem button component={Link} to={\`/documents/\${id}/forms\`}>
                    <ListItemIcon>
                      <ListAltIcon />
                    </ListItemIcon>
                    <ListItemText 
                      primary="Training Forms" 
                      secondary="View and edit assessment forms and evaluation materials" 
                    />
                  </ListItem>
                </List>
              </Box>
              
              <Box mt={4}>
                <Typography variant="h6" gutterBottom>Content Summary</Typography>
                
                <Box display="flex" flexWrap="wrap">
                  <Box mr={3} mb={2}>
                    <Chip 
                      icon={<DescriptionIcon />} 
                      label={\`\${document.extractedContent?.sections?.length || 0} Sections\`} 
                    />
                  </Box>
                  
                  <Box mr={3} mb={2}>
                    <Chip 
                      icon={<SchoolIcon />} 
                      label={\`\${document.extractedContent?.keyTerms?.length || 0} Key Terms\`} 
                    />
                  </Box>
                  
                  <Box mr={3} mb={2}>
                    <Chip 
                      icon={<VerifiedUserIcon />} 
                      label={\`\${document.extractedContent?.complianceProcedures?.length || 0} Compliance Procedures\`} 
                    />
                  </Box>
                </Box>
              </Box>
            </Box>
          )}
          
          {tabValue === 1 && (
            <Box>
              <Typography variant="h6" gutterBottom>Document Structure</Typography>
              
              {document.extractedContent?.sections?.length ? (
                <List>
                  {document.extractedContent.sections.map((section) => (
                    <React.Fragment key={section.id}>
                      <ListItem>
                        <ListItemText 
                          primary={section.title} 
                          secondary={\`Estimated time: \${section.estimatedTimeMinutes} minutes\`}
                        />
                        {(section.isCompliance || section.isSafetyCritical) && (
                          <Box>
                            {section.isCompliance && (
                              <Chip 
                                size="small" 
                                label="Compliance" 
                                style={{ marginRight: 8, backgroundColor: '#e3f2fd' }} 
                              />
                            )}
                            {section.isSafetyCritical && (
                              <Chip 
                                size="small" 
                                label="Safety Critical" 
                                style={{ backgroundColor: '#ffebee' }} 
                              />
                            )}
                          </Box>
                        )}
                      </ListItem>
                      
                      {section.subsections.length > 0 && (
                        <List style={{ paddingLeft: 32 }}>
                          {section.subsections.map((subsection) => (
                            <ListItem key={subsection.id}>
                              <ListItemText 
                                primary={subsection.title} 
                                secondary={\`Estimated time: \${subsection.estimatedTimeMinutes} minutes\`}
                              />
                              {(subsection.isCompliance || subsection.isSafetyCritical) && (
                                <Box>
                                  {subsection.isCompliance && (
                                    <Chip 
                                      size="small" 
                                      label="Compliance" 
                                      style={{ marginRight: 8, backgroundColor: '#e3f2fd' }} 
                                    />
                                  )}
                                  {subsection.isSafetyCritical && (
                                    <Chip 
                                      size="small" 
                                      label="Safety Critical" 
                                      style={{ backgroundColor: '#ffebee' }} 
                                    />
                                  )}
                                </Box>
                              )}
                            </ListItem>
                          ))}
                        </List>
                      )}
                      
                      <Divider component="li" />
                    </React.Fragment>
                  ))}
                </List>
              ) : (
                <Typography variant="body2" color="textSecondary">
                  No document structure information available
                </Typography>
              )}
            </Box>
          )}
          
          {tabValue === 2 && (
            <Box>
              <Typography variant="h6" gutterBottom>Key Terms</Typography>
              
              {document.extractedContent?.keyTerms?.length ? (
                <div>
                  {document.extractedContent.keyTerms.map((term) => (
                    <Accordion key={term.term}>
                      <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                        <Typography><strong>{term.term}</strong></Typography>
                      </AccordionSummary>
                      <AccordionDetails>
                        <Box>
                          <Typography paragraph>{term.definition}</Typography>
                          <Typography variant="body2" color="textSecondary">
                            Context: {term.context}
                          </Typography>
                          <Typography variant="body2" color="textSecondary">
                            Section: {term.section}
                          </Typography>
                          <Box mt={1}>
                            <Chip 
                              size="small" 
                              label={\`Importance: \${term.importance}/10\`} 
                            />
                          </Box>
                        </Box>
                      </AccordionDetails>
                    </Accordion>
                  ))}
                </div>
              ) : (
                <Typography variant="body2" color="textSecondary">
                  No key terms found in the document
                </Typography>
              )}
            </Box>
          )}
          
          {tabValue === 3 && (
            <Box>
              <Typography variant="h6" gutterBottom>Compliance Procedures</Typography>
              
              {document.extractedContent?.complianceProcedures?.length ? (
                <div>
                  {document.extractedContent.complianceProcedures.map((procedure) => (
                    <Accordion key={procedure.id}>
                      <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                        <Box display="flex" alignItems="center" width="100%">
                          <Typography style={{ flexGrow: 1 }}>
                            <strong>{procedure.title}</strong>
                          </Typography>
                          <Chip 
                            size="small" 
                            label={procedure.criticalityLevel.toUpperCase()} 
                            style={{ 
                              backgroundColor: 
                                procedure.criticalityLevel === 'high' ? '#ffebee' : 
                                procedure.criticalityLevel === 'medium' ? '#e8f5e9' : 
                                '#f5f5f5'
                            }} 
                          />
                        </Box>
                      </AccordionSummary>
                      <AccordionDetails>
                        <Box width="100%">
                          <Typography paragraph>{procedure.description}</Typography>
                          
                          <Typography variant="subtitle2">Steps:</Typography>
                          <List dense>
                            {procedure.steps.map((step, index) => (
                              <ListItem key={index}>
                                <ListItemText primary={\`\${index + 1}. \${step}\`} />
                              </ListItem>
                            ))}
                          </List>
                          
                          {procedure.regulation && (
                            <Box mt={2}>
                              <Typography variant="body2">
                                <strong>Regulatory Reference:</strong> {procedure.regulation}
                                {procedure.regulatoryAuthority && \` (\${procedure.regulatoryAuthority})\`}
                              </Typography>
                            </Box>
                          )}
                          
                          <Box mt={2} display="flex" flexWrap="wrap">
                            <Box mr={2} mb={1}>
                              <Chip 
                                size="small" 
                                label={\`Sign-off Required: \${procedure.requiresSignoff ? 'Yes' : 'No'}\`} 
                              />
                            </Box>
                            <Box mr={2} mb={1}>
                              <Chip 
                                size="small" 
                                label={\`Record Keeping Required: \${procedure.requiresRecordKeeping ? 'Yes' : 'No'}\`} 
                              />
                            </Box>
                          </Box>
                        </Box>
                      </AccordionDetails>
                    </Accordion>
                  ))}
                </div>
              ) : (
                <Typography variant="body2" color="textSecondary">
                  No compliance procedures identified in the document
                </Typography>
              )}
            </Box>
          )}
        </Box>
      </Paper>
    </div>
  );
}

export default DocumentView;
`;
}

/**
 * Component: SessionPlanList.jsx - List of session plans
 */
const SessionPlanList = () => {
  return `
import React, { useState, useEffect } from 'react';
import { useParams, Link, useHistory } from 'react-router-dom';
import { 
  Typography, 
  Paper, 
  Button, 
  Box, 
  Tabs, 
  Tab,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Chip,
  IconButton,
  CircularProgress
} from '@material-ui/core';
import { Alert } from '@material-ui/lab';
import EditIcon from '@material-ui/icons/Edit';
import GetAppIcon from '@material-ui/icons/GetApp';
import axios from 'axios';

function SessionPlanList() {
  const { id } = useParams();
  const history = useHistory();
  const [sessionPlans, setSessionPlans] = useState([]);
  const [document, setDocument] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [tabValue, setTabValue] = useState(0);

  useEffect(() => {
    // Fetch session plans
    fetchData();
  }, [id]);

  const fetchData = async () => {
    setLoading(true);
    try {
      // Fetch document info
      const docResponse = await axios.get(\`/api/documents/\${id}\`);
      setDocument(docResponse.data);
      
      // Fetch session plans
      const plansResponse = await axios.get(\`/api/documents/\${id}/session-plans\`);
      setSessionPlans(plansResponse.data);
      setLoading(false);
    } catch (err) {
      console.error('Error fetching data:', err);
      setError('Failed to load session plans');
      setLoading(false);
    }
  };

  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  const handleGenerateSessionPlans = async () => {
    try {
      setLoading(true);
      await axios.post(\`/api/documents/\${id}/session-plans\`);
      // Refresh the data
      fetchData();
    } catch (err) {
      console.error('Error generating session plans:', err);
      setError('Failed to generate session plans');
      setLoading(false);
    }
  };

  const handleExportPlan = async (planId) => {
    try {
      const response = await axios.get(\`/api/session-plans/\${planId}/export\`, {
        responseType: 'blob'
      });
      
      // Create a download link
      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', \`session-plan-\${planId}.docx\`);
      document.body.appendChild(link);
      link.click();
      
      // Cleanup
      link.parentNode.removeChild(link);
      window.URL.revokeObjectURL(url);
    } catch (err) {
      console.error('Error exporting session plan:', err);
      alert('Failed to export session plan. Please try again later.');
    }
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" my={4}>
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Paper style={{ padding: 20 }}>
        <Alert severity="error">{error}</Alert>
        <Box mt={2}>
          <Button variant="contained" component={Link} to={\`/documents/\${id}\`}>
            Return to Document
          </Button>
        </Box>
      </Paper>
    );
  }

  // Filter session plans based on selected tab
  const filteredPlans = sessionPlans.filter(plan => 
    (tabValue === 0 && plan.planType === 'instructor') || 
    (tabValue === 1 && plan.planType === 'student')
  );

  return (
    <div>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <div>
          <Typography variant="h4" gutterBottom>
            Session Plans
          </Typography>
          <Typography variant="subtitle1" color="textSecondary">
            {document?.metadata?.title || document?.originalFilename}
          </Typography>
        </div>
        
        <Button 
          variant="contained" 
          color="primary" 
          onClick={handleGenerateSessionPlans}
        >
          Regenerate Session Plans
        </Button>
      </Box>
      
      <Paper style={{ marginBottom: 20 }}>
        <Tabs 
          value={tabValue} 
          onChange={handleTabChange} 
          indicatorColor="primary"
          textColor="primary"
        >
          <Tab label="Instructor Plans" />
          <Tab label="Student Plans" />
        </Tabs>
        
        <Box p={3}>
          {filteredPlans.length === 0 ? (
            <Alert severity="info">
              No {tabValue === 0 ? 'instructor' : 'student'} session plans found for this document.
            </Alert>
          ) : (
            <TableContainer>
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell><strong>Title</strong></TableCell>
                    <TableCell><strong>Duration</strong></TableCell>
                    <TableCell><strong>Activities</strong></TableCell>
                    <TableCell><strong>Compliance Items</strong></TableCell>
                    <TableCell><strong>Actions</strong></TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {filteredPlans.map((plan) => (
                    <TableRow key={plan._id}>
                      <TableCell>
                        <Typography variant="body1">{plan.title}</Typography>
                        <Typography variant="body2" color="textSecondary">
                          {plan.description.substring(0, 100)}...
                        </Typography>
                      </TableCell>
                      <TableCell>
                        {plan.duration} minutes
                      </TableCell>
                      <TableCell>
                        {plan.activities.length} activities
                        <Box mt={1}>
                          {plan.activities.slice(0, 3).map((activity, index) => (
                            <Chip 
                              key={index}
                              size="small"
                              label={activity.type}
                              style={{ margin: '0 4px 4px 0' }}
                            />
                          ))}
                          {plan.activities.length > 3 && (
                            <Chip 
                              size="small"
                              label={`+${plan.activities.length - 3} more`}
                            />
                          )}
                        </Box>
                      </TableCell>
                      <TableCell>
                        {plan.complianceCoverage ? 
                          \`\${plan.complianceCoverage.filter(item => item.covered).length} covered\` : 
                          'None'}
                      </TableCell>
                      <TableCell>
                        <IconButton 
                          component={Link} 
                          to={\`/session-plans/\${plan._id}/edit\`}
                          title="Edit session plan"
                        >
                          <EditIcon />
                        </IconButton>
                        <IconButton 
                          onClick={() => handleExportPlan(plan._id)}
                          title="Export to DOCX"
                        >
                          <GetAppIcon />
                        </IconButton>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          )}
        </Box>
      </Paper>
      
      <Button 
        variant="outlined" 
        component={Link} 
        to={\`/documents/\${id}\`}
      >
        Back to Document
      </Button>
    </div>
  );
}

export default SessionPlanList;
`;
}

/**
 * Component: SessionPlanEditor.jsx - Session plan editing component
 */
const SessionPlanEditor = () => {
  return `
import React, { useState, useEffect } from 'react';
import { useParams, useHistory } from 'react-router-dom';
import { 
  Typography, 
  Paper, 
  Box, 
  Button, 
  TextField, 
  Grid,
  Divider,
  IconButton,
  Card,
  CardContent,
  CardActions,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  MenuItem,
  FormControl,
  InputLabel,
  Select,
  Chip
} from '@material-ui/core';
import { Alert } from '@material-ui/lab';
import AddIcon from '@material-ui/icons/Add';
import DeleteIcon from '@material-ui/icons/Delete';
import EditIcon from '@material-ui/icons/Edit';
import SaveIcon from '@material-ui/icons/Save';
import GetAppIcon from '@material-ui/icons/GetApp';
import axios from 'axios';

function SessionPlanEditor() {
  const { id } = useParams();
  const history = useHistory();
  const [sessionPlan, setSessionPlan] = useState(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState(null);
  const [editingActivity, setEditingActivity] = useState(null);
  const [activityDialogOpen, setActivityDialogOpen] = useState(false);
  const [editingMaterial, setEditingMaterial] = useState(null);
  const [materialDialogOpen, setMaterialDialogOpen] = useState(false);

  useEffect(() => {
    // Fetch session plan
    fetchSessionPlan();
  }, [id]);

  const fetchSessionPlan = async () => {
    try {
      const response = await axios.get(\`/api/session-plans/\${id}\`);
      setSessionPlan(response.data);
      setLoading(false);
    } catch (err) {
      console.error('Error fetching session plan:', err);
      setError('Failed to load session plan');
      setLoading(false);
    }
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setSessionPlan(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleArrayInputChange = (e, index, arrayName, fieldName) => {
    const { value } = e.target;
    setSessionPlan(prev => {
      const newArray = [...prev[arrayName]];
      newArray[index] = {
        ...newArray[index],
        [fieldName]: value
      };
      return {
        ...prev,
        [arrayName]: newArray
      };
    });
  };

  const handleSave = async () => {
    try {
      setSaving(true);
      await axios.put(\`/api/session-plans/\${id}\`, sessionPlan);
      setSaving(false);
      // Redirect back to session plans list
      const documentId = sessionPlan.documentId;
      history.push(\`/documents/\${documentId}/sessions\`);
    } catch (err) {
      console.error('Error saving session plan:', err);
      setError('Failed to save session plan');
      setSaving(false);
    }
  };

  const handleCancel = () => {
    // Redirect back to session plans list
    const documentId = sessionPlan.documentId;
    history.push(\`/documents/\${documentId}/sessions\`);
  };

  // Activity Dialog Handlers
  const handleOpenActivityDialog = (activity = null) => {
    setEditingActivity(activity || {
      id: \`activity-\${Date.now()}\`,
      title: '',
      type: 'lecture',
      description: '',
      duration: 15,
      materials: [],
      instructorNotes: sessionPlan.planType === 'instructor' ? '' : undefined,
      contentReferences: []
    });
    setActivityDialogOpen(true);
  };

  const handleCloseActivityDialog = () => {
    setActivityDialogOpen(false);
    setEditingActivity(null);
  };

  const handleActivityInputChange = (e) => {
    const { name, value } = e.target;
    setEditingActivity(prev => ({
      ...prev,
      [name]: name === 'duration' ? parseInt(value, 10) : value
    }));
  };

  const handleSaveActivity = () => {
    setSessionPlan(prev => {
      const isNew = !prev.activities.some(a => a.id === editingActivity.id);
      let newActivities;
      
      if (isNew) {
        newActivities = [...prev.activities, editingActivity];
      } else {
        newActivities = prev.activities.map(a => 
          a.id === editingActivity.id ? editingActivity : a
        );
      }
      
      return {
        ...prev,
        activities: newActivities
      };
    });
    
    setActivityDialogOpen(false);
    setEditingActivity(null);
  };

  const handleDeleteActivity = (activityId) => {
    setSessionPlan(prev => ({
      ...prev,
      activities: prev.activities.filter(a => a.id !== activityId)
    }));
  };

  // Material Dialog Handlers
  const handleOpenMaterialDialog = (material = null) => {
    setEditingMaterial(material || {
      id: \`material-\${Date.now()}\`,
      title: '',
      type: 'handout',
      description: '',
      source: '',
      required: true
    });
    setMaterialDialogOpen(true);
  };

  const handleCloseMaterialDialog = () => {
    setMaterialDialogOpen(false);
    setEditingMaterial(null);
  };

  const handleMaterialInputChange = (e) => {
    const { name, value, checked, type } = e.target;
    setEditingMaterial(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const handleSaveMaterial = () => {
    setSessionPlan(prev => {
      const isNew = !prev.materials.some(m => m.id === editingMaterial.id);
      let newMaterials;
      
      if (isNew) {
        newMaterials = [...prev.materials, editingMaterial];
      } else {
        newMaterials = prev.materials.map(m => 
          m.id === editingMaterial.id ? editingMaterial : m
        );
      }
      
      return {
        ...prev,
        materials: newMaterials
      };
    });
    
    setMaterialDialogOpen(false);
    setEditingMaterial(null);
  };

  const handleDeleteMaterial = (materialId) => {
    setSessionPlan(prev => ({
      ...prev,
      materials: prev.materials.filter(m => m.id !== materialId)
    }));
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" my={4}>
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Paper style={{ padding: 20 }}>
        <Alert severity="error">{error}</Alert>
        <Box mt={2}>
          <Button variant="contained" onClick={() => history.goBack()}>
            Go Back
          </Button>
        </Box>
      </Paper>
    );
  }

  if (!sessionPlan) {
    return (
      <Paper style={{ padding: 20 }}>
        <Alert severity="warning">Session plan not found</Alert>
        <Box mt={2}>
          <Button variant="contained" onClick={() => history.goBack()}>
            Go Back
          </Button>
        </Box>
      </Paper>
    );
  }

  return (
    <div>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Typography variant="h4">
          Edit {sessionPlan.planType === 'instructor' ? 'Instructor' : 'Student'} Session Plan
        </Typography>
        
        <Box>
          <Button 
            variant="contained" 
            color="primary" 
            startIcon={<SaveIcon />}
            onClick={handleSave}
            disabled={saving}
            style={{ marginRight: 8 }}
          >
            {saving ? 'Saving...' : 'Save Changes'}
          </Button>
          <Button 
            variant="outlined"
            onClick={handleCancel}
            disabled={saving}
          >
            Cancel
          </Button>
        </Box>
      </Box>
      
      <Paper style={{ padding: 20, marginBottom: 20 }}>
        <Typography variant="h6" gutterBottom>Basic Information</Typography>
        
        <Grid container spacing={3}>
          <Grid item xs={12} sm={8}>
            <TextField
              fullWidth
              label="Session Title"
              name="title"
              value={sessionPlan.title}
              onChange={handleInputChange}
              variant="outlined"
              margin="normal"
            />
          </Grid>
          
          <Grid item xs={12} sm={4}>
            <TextField
              fullWidth
              label="Duration (minutes)"
              name="duration"
              type="number"
              value={sessionPlan.duration}
              onChange={handleInputChange}
              variant="outlined"
              margin="normal"
              inputProps={{ min: 15, max: 480 }}
            />
          </Grid>
          
          <Grid item xs={12}>
            <TextField
              fullWidth
              label="Description"
              name="description"
              value={sessionPlan.description}
              onChange={handleInputChange}
              variant="outlined"
              margin="normal"
              multiline
              rows={4}
            />
          </Grid>
          
          <Grid item xs={12}>
            <TextField
              fullWidth
              label="Target Audience"
              name="targetAudience"
              value={sessionPlan.targetAudience}
              onChange={handleInputChange}
              variant="outlined"
              margin="normal"
            />
          </Grid>
        </Grid>
      </Paper>
      
      <Paper style={{ padding: 20, marginBottom: 20 }}>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
          <Typography variant="h6">Learning Objectives</Typography>
          <Button 
            startIcon={<AddIcon />}
            onClick={() => {
              setSessionPlan(prev => ({
                ...prev,
                learningObjectives: [...prev.learningObjectives, '']
              }));
            }}
          >
            Add Objective
          </Button>
        </Box>
        
        {sessionPlan.learningObjectives.map((objective, index) => (
          <Box key={index} display="flex" alignItems="center" mb={2}>
            <TextField
              fullWidth
              label={\`Objective #\${index + 1}\`}
              value={objective}
              onChange={(e) => {
                const newObjectives = [...sessionPlan.learningObjectives];
                newObjectives[index] = e.target.value;
                setSessionPlan(prev => ({
                  ...prev,
                  learningObjectives: newObjectives
                }));
              }}
              variant="outlined"
              margin="dense"
            />
            <IconButton 
              onClick={() => {
                const newObjectives = sessionPlan.learningObjectives.filter((_, i) => i !== index);
                setSessionPlan(prev => ({
                  ...prev,
                  learningObjectives: newObjectives
                }));
              }}
            >
              <DeleteIcon />
            </IconButton>
          </Box>
        ))}
      </Paper>
      
      <Paper style={{ padding: 20, marginBottom: 20 }}>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
          <Typography variant="h6">Session Activities</Typography>
          <Button 
            startIcon={<AddIcon />}
            onClick={() => handleOpenActivityDialog()}
          >
            Add Activity
          </Button>
        </Box>
        
        {sessionPlan.activities.length === 0 ? (
          <Alert severity="info" style={{ marginBottom: 20 }}>
            No activities defined. Click "Add Activity" to create your first session activity.
          </Alert>
        ) : (
          <Grid container spacing={3}>
            {sessionPlan.activities.map((activity, index) => (
              <Grid item xs={12} sm={6} md={4} key={activity.id}>
                <Card>
                  <CardContent>
                    <Box display="flex" justifyContent="space-between" alignItems="center" mb={1}>
                      <Typography variant="h6">{activity.title}</Typography>
                      <Chip 
                        label={activity.type}
                        size="small"
                      />
                    </Box>
                    <Typography variant="body2" color="textSecondary" gutterBottom>
                      Duration: {activity.duration} minutes
                    </Typography>
                    <Typography variant="body2">
                      {activity.description}
                    </Typography>
                    {activity.instructorNotes && (
                      <Box mt={1}>
                        <Typography variant="body2" color="textSecondary">
                          <strong>Instructor Notes:</strong>
                        </Typography>
                        <Typography variant="body2" color="textSecondary">
                          {activity.instructorNotes}
                        </Typography>
                      </Box>
                    )}
                  </CardContent>
                  <CardActions>
                    <IconButton 
                      size="small" 
                      onClick={() => handleOpenActivityDialog(activity)}
                    >
                      <EditIcon />
                    </IconButton>
                    <IconButton 
                      size="small" 
                      onClick={() => handleDeleteActivity(activity.id)}
                    >
                      <DeleteIcon />
                    </IconButton>
                  </CardActions>
                </Card>
              </Grid>
            ))}
          </Grid>
        )}
      </Paper>
      
      <Paper style={{ padding: 20, marginBottom: 20 }}>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
          <Typography variant="h6">Required Materials</Typography>
          <Button 
            startIcon={<AddIcon />}
            onClick={() => handleOpenMaterialDialog()}
          >
            Add Material
          </Button>
        </Box>
        
        {sessionPlan.materials.length === 0 ? (
          <Alert severity="info" style={{ marginBottom: 20 }}>
            No materials defined. Click "Add Material" to specify required materials.
          </Alert>
        ) : (
          <Grid container spacing={3}>
            {sessionPlan.materials.map((material, index) => (
              <Grid item xs={12} sm={6} key={material.id}>
                <Card>
                  <CardContent>
                    <Box display="flex" justifyContent="space-between" alignItems="center" mb={1}>
                      <Typography variant="h6">{material.title}</Typography>
                      <Chip 
                        label={material.type}
                        size="small"
                      />
                    </Box>
                    <Typography variant="body2">
                      {material.description}
                    </Typography>
                    {material.source && (
                      <Typography variant="body2" color="textSecondary">
                        Source: {material.source}
                      </Typography>
                    )}
                    <Box mt={1}>
                      <Chip 
                        label={material.required ? 'Required' : 'Optional'}
                        size="small"
                        color={material.required ? 'primary' : 'default'}
                      />
                    </Box>
                  </CardContent>
                  <CardActions>
                    <IconButton 
                      size="small" 
                      onClick={() => handleOpenMaterialDialog(material)}
                    >
                      <EditIcon />
                    </IconButton>
                    <IconButton 
                      size="small" 
                      onClick={() => handleDeleteMaterial(material.id)}
                    >
                      <DeleteIcon />
                    </IconButton>
                  </CardActions>
                </Card>
              </Grid>
            ))}
          </Grid>
        )}
      </Paper>
      
      {/* Instructor-specific sections */}
      {sessionPlan.planType === 'instructor' && (
        <Paper style={{ padding: 20, marginBottom: 20 }}>
          <Typography variant="h6" gutterBottom>Instructor Notes</Typography>
          
          {sessionPlan.instructorNotes && sessionPlan.instructorNotes.map((note, index) => (
            <Box key={index} display="flex" alignItems="center" mb={2}>
              <TextField
                fullWidth
                label={\`Note #\${index + 1}\`}
                value={note}
                onChange={(e) => {
                  const newNotes = [...sessionPlan.instructorNotes];
                  newNotes[index] = e.target.value;
                  setSessionPlan(prev => ({
                    ...prev,
                    instructorNotes: newNotes
                  }));
                }}
                variant="outlined"
                margin="dense"
                multiline
                rows={2}
              />
              <IconButton 
                onClick={() => {
                  const newNotes = sessionPlan.instructorNotes.filter((_, i) => i !== index);
                  setSessionPlan(prev => ({
                    ...prev,
                    instructorNotes: newNotes
                  }));
                }}
              >
                <DeleteIcon />
              </IconButton>
            </Box>
          ))}
          
          <Button 
            startIcon={<AddIcon />}
            onClick={() => {
              setSessionPlan(prev => ({
                ...prev,
                instructorNotes: [...(prev.instructorNotes || []), '']
              }));
            }}
          >
            Add Instructor Note
          </Button>
        </Paper>
      )}
      
      {/* Student-specific sections */}
      {sessionPlan.planType === 'student' && (
        <Paper style={{ padding: 20, marginBottom: 20 }}>
          <Typography variant="h6" gutterBottom>Student Preparation</Typography>
          
          {sessionPlan.studentPreparation && sessionPlan.studentPreparation.map((prep, index) => (
            <Box key={index} display="flex" alignItems="center" mb={2}>
              <TextField
                fullWidth
                label={\`Preparation Item #\${index + 1}\`}
                value={prep}
                onChange={(e) => {
                  const newPrep = [...sessionPlan.studentPreparation];
                  newPrep[index] = e.target.value;
                  setSessionPlan(prev => ({
                    ...prev,
                    studentPreparation: newPrep
                  }));
                }}
                variant="outlined"
                margin="dense"
              />
              <IconButton 
                onClick={() => {
                  const newPrep = sessionPlan.studentPreparation.filter((_, i) => i !== index);
                  setSessionPlan(prev => ({
                    ...prev,
                    studentPreparation: newPrep
                  }));
                }}
              >
                <DeleteIcon />
              </IconButton>
            </Box>
          ))}
          
          <Button 
            startIcon={<AddIcon />}
            onClick={() => {
              setSessionPlan(prev => ({
                ...prev,
                studentPreparation: [...(prev.studentPreparation || []), '']
              }));
            }}
          >
            Add Preparation Item
          </Button>
        </Paper>
      )}
      
      <Box display="flex" justifyContent="space-between" mb={4}>
        <Button variant="outlined" onClick={handleCancel}>
          Cancel
        </Button>
        
        <Button 
          variant="contained" 
          color="primary" 
          startIcon={<SaveIcon />}
          onClick={handleSave}
          disabled={saving}
        >
          {saving ? 'Saving...' : 'Save Changes'}
        </Button>
      </Box>
      
      {/* Activity Dialog */}
      <Dialog open={activityDialogOpen} onClose={handleCloseActivityDialog} maxWidth="md" fullWidth>
        <DialogTitle>
          {editingActivity && editingActivity.id ? 'Edit Activity' : 'Add Activity'}
        </DialogTitle>
        <DialogContent>
          <Grid container spacing={3}>
            <Grid item xs={12} sm={8}>
              <TextField
                fullWidth
                label="Activity Title"
                name="title"
                value={editingActivity?.title || ''}
                onChange={handleActivityInputChange}
                variant="outlined"
                margin="normal"
                required
              />
            </Grid>
            
            <Grid item xs={12} sm={4}>
              <FormControl variant="outlined" fullWidth margin="normal">
                <InputLabel>Activity Type</InputLabel>
                <Select
                  name="type"
                  value={editingActivity?.type || 'lecture'}
                  onChange={handleActivityInputChange}
                  label="Activity Type"
                >
                  <MenuItem value="lecture">Lecture</MenuItem>
                  <MenuItem value="discussion">Discussion</MenuItem>
                  <MenuItem value="demonstration">Demonstration</MenuItem>
                  <MenuItem value="practice">Practice</MenuItem>
                  <MenuItem value="assessment">Assessment</MenuItem>
                  <MenuItem value="break">Break</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Duration (minutes)"
                name="duration"
                type="number"
                value={editingActivity?.duration || 15}
                onChange={handleActivityInputChange}
                variant="outlined"
                margin="normal"
                inputProps={{ min: 5, max: 120 }}
                required
              />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Description"
                name="description"
                value={editingActivity?.description || ''}
                onChange={handleActivityInputChange}
                variant="outlined"
                margin="normal"
                multiline
                rows={3}
                required
              />
            </Grid>
            
            {sessionPlan.planType === 'instructor' && (
              <Grid item xs={12}>
                <TextField
                  fullWidth
                  label="Instructor Notes"
                  name="instructorNotes"
                  value={editingActivity?.instructorNotes || ''}
                  onChange={handleActivityInputChange}
                  variant="outlined"
                  margin="normal"
                  multiline
                  rows={3}
                />
              </Grid>
            )}
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseActivityDialog} color="default">
            Cancel
          </Button>
          <Button onClick={handleSaveActivity} color="primary" variant="contained">
            Save
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Material Dialog */}
      <Dialog open={materialDialogOpen} onClose={handleCloseMaterialDialog} maxWidth="md" fullWidth>
        <DialogTitle>
          {editingMaterial && editingMaterial.id ? 'Edit Material' : 'Add Material'}
        </DialogTitle>
        <DialogContent>
          <Grid container spacing={3}>
            <Grid item xs={12} sm={8}>
              <TextField
                fullWidth
                label="Material Title"
                name="title"
                value={editingMaterial?.title || ''}
                onChange={handleMaterialInputChange}
                variant="outlined"
                margin="normal"
                required
              />
            </Grid>
            
            <Grid item xs={12} sm={4}>
              <FormControl variant="outlined" fullWidth margin="normal">
                <InputLabel>Material Type</InputLabel>
                <Select
                  name="type"
                  value={editingMaterial?.type || 'handout'}
                  onChange={handleMaterialInputChange}
                  label="Material Type"
                >
                  <MenuItem value="handout">Handout</MenuItem>
                  <MenuItem value="presentation">Presentation</MenuItem>
                  <MenuItem value="reference">Reference</MenuItem>
                  <MenuItem value="equipment">Equipment</MenuItem>
                  <MenuItem value="software">Software</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Description"
                name="description"
                value={editingMaterial?.description || ''}
                onChange={handleMaterialInputChange}
                variant="outlined"
                margin="normal"
                multiline
                rows={2}
                required
              />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Source/Reference (optional)"
                name="source"
                value={editingMaterial?.source || ''}
                onChange={handleMaterialInputChange}
                variant="outlined"
                margin="normal"
              />
            </Grid>
            
            <Grid item xs={12}>
              <FormControl component="fieldset" margin="normal">
                <Typography variant="body2">
                  <label>
                    <input
                      type="checkbox"
                      name="required"
                      checked={editingMaterial?.required !== false}
                      onChange={handleMaterialInputChange}
                    />
                    {' '}
                    This material is required for the session
                  </label>
                </Typography>
              </FormControl>
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseMaterialDialog} color="default">
            Cancel
          </Button>
          <Button onClick={handleSaveMaterial} color="primary" variant="contained">
            Save
          </Button>
        </DialogActions>
      </Dialog>
    </div>
  );
}

export default SessionPlanEditor;
`;
}

/**
 * Component: TrainingFormEditor.jsx - Training form editor component
 */
const TrainingFormEditor = () => {
  return `
import React, { useState, useEffect } from 'react';
import { useParams, useHistory } from 'react-router-dom';
import { 
  Typography, 
  Paper, 
  Box, 
  Button, 
  TextField, 
  Grid,
  Divider,
  IconButton,
  Card,
  CardContent,
  CardActions,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  MenuItem,
  FormControl,
  InputLabel,
  Select,
  Chip,
  Radio,
  RadioGroup,
  FormControlLabel,
  FormLabel,
  Accordion,
  AccordionSummary,
  AccordionDetails
} from '@material-ui/core';
import { Alert } from '@material-ui/lab';
import AddIcon from '@material-ui/icons/Add';
import DeleteIcon from '@material-ui/icons/Delete';
import EditIcon from '@material-ui/icons/Edit';
import SaveIcon from '@material-ui/icons/Save';
import GetAppIcon from '@material-ui/icons/GetApp';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import axios from 'axios';

function TrainingFormEditor() {
  const { id } = useParams();
  const history = useHistory();
  const [trainingForm, setTrainingForm] = useState(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState(null);
  const [editingQuestion, setEditingQuestion] = useState(null);
  const [questionDialogOpen, setQuestionDialogOpen] = useState(false);
  const [editingTask, setEditingTask] = useState(null);
  const [taskDialogOpen, setTaskDialogOpen] = useState(false);
  const [editingSignoff, setEditingSignoff] = useState(null);
  const [signoffDialogOpen, setSignoffDialogOpen] = useState(false);

  useEffect(() => {
    // Fetch training form
    fetchTrainingForm();
  }, [id]);

  const fetchTrainingForm = async () => {
    try {
      const response = await axios.get(\`/api/training-forms/\${id}\`);
      setTrainingForm(response.data);
      setLoading(false);
    } catch (err) {
      console.error('Error fetching training form:', err);
      setError('Failed to load training form');
      setLoading(false);
    }
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setTrainingForm(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleSave = async () => {
    try {
      setSaving(true);
      await axios.put(\`/api/training-forms/\${id}\`, trainingForm);
      setSaving(false);
      // Redirect back to training forms list
      const documentId = trainingForm.documentId;
      history.push(\`/documents/\${documentId}/forms\`);
    } catch (err) {
      console.error('Error saving training form:', err);
      setError('Failed to save training form');
      setSaving(false);
    }
  };

  const handleCancel = () => {
    // Redirect back to training forms list
    const documentId = trainingForm.documentId;
    history.push(\`/documents/\${documentId}/forms\`);
  };

  // Question Dialog Handlers
  const handleOpenQuestionDialog = (question = null) => {
    setEditingQuestion(question || {
      id: \`q-\${Date.now()}\`,
      type: 'multiple-choice',
      question: '',
      options: ['', '', '', ''],
      correctAnswer: '',
      points: 1,
      explanation: ''
    });
    setQuestionDialogOpen(true);
  };

  const handleCloseQuestionDialog = () => {
    setQuestionDialogOpen(false);
    setEditingQuestion(null);
  };

  const handleQuestionInputChange = (e) => {
    const { name, value } = e.target;
    setEditingQuestion(prev => ({
      ...prev,
      [name]: name === 'points' ? parseInt(value, 10) : value
    }));
  };

  const handleOptionChange = (index, value) => {
    setEditingQuestion(prev => {
      const newOptions = [...prev.options];
      newOptions[index] = value;
      return { ...prev, options: newOptions };
    });
  };

  const handleCorrectAnswerChange = (value) => {
    setEditingQuestion(prev => ({
      ...prev,
      correctAnswer: value
    }));
  };

  const handleAddOption = () => {
    setEditingQuestion(prev => ({
      ...prev,
      options: [...prev.options, '']
    }));
  };

  const handleRemoveOption = (index) => {
    setEditingQuestion(prev => {
      const newOptions = prev.options.filter((_, i) => i !== index);
      return { ...prev, options: newOptions };
    });
  };

  const handleSaveQuestion = () => {
    setTrainingForm(prev => {
      const isNew = !prev.questions.some(q => q.id === editingQuestion.id);
      let newQuestions;
      
      if (isNew) {
        newQuestions = [...prev.questions, editingQuestion];
      } else {
        newQuestions = prev.questions.map(q => 
          q.id === editingQuestion.id ? editingQuestion : q
        );
      }
      
      return {
        ...prev,
        questions: newQuestions
      };
    });
    
    setQuestionDialogOpen(false);
    setEditingQuestion(null);
  };

  const handleDeleteQuestion = (questionId) => {
    setTrainingForm(prev => ({
      ...prev,
      questions: prev.questions.filter(q => q.id !== questionId)
    }));
  };

  // Task Dialog Handlers
  const handleOpenTaskDialog = (task = null) => {
    setEditingTask(task || {
      id: \`task-\${Date.now()}\`,
      description: '',
      criteria: [''],
      passingThreshold: 70,
      timeAllotted: 15,
      equipmentNeeded: []
    });
    setTaskDialogOpen(true);
  };

  const handleCloseTaskDialog = () => {
    setTaskDialogOpen(false);
    setEditingTask(null);
  };

  const handleTaskInputChange = (e) => {
    const { name, value } = e.target;
    setEditingTask(prev => ({
      ...prev,
      [name]: ['passingThreshold', 'timeAllotted'].includes(name) 
        ? parseInt(value, 10) 
        : value
    }));
  };

  const handleCriteriaChange = (index, value) => {
    setEditingTask(prev => {
      const newCriteria = [...prev.criteria];
      newCriteria[index] = value;
      return { ...prev, criteria: newCriteria };
    });
  };

  const handleAddCriteria = () => {
    setEditingTask(prev => ({
      ...prev,
      criteria: [...prev.criteria, '']
    }));
  };

  const handleRemoveCriteria = (index) => {
    setEditingTask(prev => {
      const newCriteria = prev.criteria.filter((_, i) => i !== index);
      return { ...prev, criteria: newCriteria };
    });
  };

  const handleEquipmentChange = (e) => {
    const equipmentText = e.target.value;
    const equipmentList = equipmentText.split(',').map(item => item.trim()).filter(item => item);
    
    setEditingTask(prev => ({
      ...prev,
      equipmentNeeded: equipmentList
    }));
  };

  const handleSaveTask = () => {
    setTrainingForm(prev => {
      const practicalTasks = prev.practicalTasks || [];
      const isNew = !practicalTasks.some(t => t.id === editingTask.id);
      let newTasks;
      
      if (isNew) {
        newTasks = [...practicalTasks, editingTask];
      } else {
        newTasks = practicalTasks.map(t => 
          t.id === editingTask.id ? editingTask : t
        );
      }
      
      return {
        ...prev,
        practicalTasks: newTasks
      };
    });
    
    setTaskDialogOpen(false);
    setEditingTask(null);
  };

  const handleDeleteTask = (taskId) => {
    setTrainingForm(prev => ({
      ...prev,
      practicalTasks: (prev.practicalTasks || []).filter(t => t.id !== taskId)
    }));
  };

  // Signoff Dialog Handlers
  const handleOpenSignoffDialog = (signoff = null) => {
    setEditingSignoff(signoff || {
      title: '',
      role: 'Instructor',
      description: '',
      regulatoryReference: ''
    });
    setSignoffDialogOpen(true);
  };

  const handleCloseSignoffDialog = () => {
    setSignoffDialogOpen(false);
    setEditingSignoff(null);
  };

  const handleSignoffInputChange = (e) => {
    const { name, value } = e.target;
    setEditingSignoff(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleSaveSignoff = () => {
    setTrainingForm(prev => {
      const signoffRequirements = prev.signoffRequirements || [];
      const isNew = !signoffRequirements.some(s => 
        s.title === editingSignoff.title && s.role === editingSignoff.role
      );
      let newSignoffs;
      
      if (isNew) {
        newSignoffs = [...signoffRequirements, editingSignoff];
      } else {
        newSignoffs = signoffRequirements.map(s => 
          (s.title === editingSignoff.title && s.role === editingSignoff.role) ? editingSignoff : s
        );
      }
      
      return {
        ...prev,
        signoffRequirements: newSignoffs
      };
    });
    
    setSignoffDialogOpen(false);
    setEditingSignoff(null);
  };

  const handleDeleteSignoff = (title, role) => {
    setTrainingForm(prev => ({
      ...prev,
      signoffRequirements: (prev.signoffRequirements || []).filter(s => 
        !(s.title === title && s.role === role)
      )
    }));
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" my={4}>
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Paper style={{ padding: 20 }}>
        <Alert severity="error">{error}</Alert>
        <Box mt={2}>
          <Button variant="contained" onClick={() => history.goBack()}>
            Go Back
          </Button>
        </Box>
      </Paper>
    );
  }

  if (!trainingForm) {
    return (
      <Paper style={{ padding: 20 }}>
        <Alert severity="warning">Training form not found</Alert>
        <Box mt={2}>
          <Button variant="contained" onClick={() => history.goBack()}>
            Go Back
          </Button>
        </Box>
      </Paper>
    );
  }

  return (
    <div>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Typography variant="h4">
          Edit Training Form
        </Typography>
        
        <Box>
          <Button 
            variant="contained" 
            color="primary" 
            startIcon={<SaveIcon />}
            onClick={handleSave}
            disabled={saving}
            style={{ marginRight: 8 }}
          >
            {saving ? 'Saving...' : 'Save Changes'}
          </Button>
          <Button 
            variant="outlined"
            onClick={handleCancel}
            disabled={saving}
          >
            Cancel
          </Button>
        </Box>
      </Box>
      
      <Paper style={{ padding: 20, marginBottom: 20 }}>
        <Typography variant="h6" gutterBottom>Basic Information</Typography>
        
        <Grid container spacing={3}>
          <Grid item xs={12}>
            <TextField
              fullWidth
              label="Form Title"
              name="title"
              value={trainingForm.title}
              onChange={handleInputChange}
              variant="outlined"
              margin="normal"
            />
          </Grid>
          
          <Grid item xs={12}>
            <TextField
              fullWidth
              label="Description"
              name="description"
              value={trainingForm.description}
              onChange={handleInputChange}
              variant="outlined"
              margin="normal"
              multiline
              rows={3}
            />
          </Grid>
        </Grid>
      </Paper>
      
      <Paper style={{ padding: 20, marginBottom: 20 }}>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
          <Typography variant="h6">Assessment Questions</Typography>
          <Button 
            startIcon={<AddIcon />}
            onClick={() => handleOpenQuestionDialog()}
          >
            Add Question
          </Button>
        </Box>
        
        {!trainingForm.questions || trainingForm.questions.length === 0 ? (
          <Alert severity="info" style={{ marginBottom: 20 }}>
            No questions defined. Click "Add Question" to create your first assessment question.
          </Alert>
        ) : (
          <div>
            {trainingForm.questions.map((question) => (
              <Accordion key={question.id}>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Box display="flex" alignItems="center" width="100%">
                    <Typography style={{ flexGrow: 1 }}>
                      {question.question.substring(0, 100)}
                      {question.question.length > 100 ? '...' : ''}
                    </Typography>
                    <Chip 
                      size="small" 
                      label={question.type.replace('-', ' ')}
                      style={{ marginRight: 8 }}
                    />
                    <Chip 
                      size="small" 
                      label={\`\${question.points} pt\${question.points !== 1 ? 's' : ''}\`}
                    />
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Box width="100%">
                    <Typography variant="body1" paragraph>
                      {question.question}
                    </Typography>
                    
                    {question.type === 'multiple-choice' && question.options && (
                      <Box mb={2}>
                        <Typography variant="subtitle2">Options:</Typography>
                        <ul>
                          {question.options.map((option, index) => (
                            <li key={index}>
                              <Typography variant="body2">
                                {option === question.correctAnswer ? (
                                  <strong>{option} (Correct)</strong>
                                ) : (
                                  option
                                )}
                              </Typography>
                            </li>
                          ))}
                        </ul>
                      </Box>
                    )}
                    
                    {question.type === 'true-false' && (
                      <Box mb={2}>
                        <Typography variant="subtitle2">Correct Answer:</Typography>
                        <Typography variant="body2">{question.correctAnswer}</Typography>
                      </Box>
                    )}
                    
                    {question.explanation && (
                      <Box mb={2}>
                        <Typography variant="subtitle2">Explanation:</Typography>
                        <Typography variant="body2">{question.explanation}</Typography>
                      </Box>
                    )}
                    
                    <Box display="flex" justifyContent="flex-end" mt={2}>
                      <Button 
                        size="small" 
                        startIcon={<EditIcon />}
                        onClick={() => handleOpenQuestionDialog(question)}
                        style={{ marginRight: 8 }}
                      >
                        Edit
                      </Button>
                      <Button 
                        size="small" 
                        startIcon={<DeleteIcon />}
                        onClick={() => handleDeleteQuestion(question.id)}
                      >
                        Delete
                      </Button>
                    </Box>
                  </Box>
                </AccordionDetails>
              </Accordion>
            ))}
          </div>
        )}
      </Paper>
      
      <Paper style={{ padding: 20, marginBottom: 20 }}>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
          <Typography variant="h6">Practical Tasks</Typography>
          <Button 
            startIcon={<AddIcon />}
            onClick={() => handleOpenTaskDialog()}
          >
            Add Task
          </Button>
        </Box>
        
        {!trainingForm.practicalTasks || trainingForm.practicalTasks.length === 0 ? (
          <Alert severity="info" style={{ marginBottom: 20 }}>
            No practical tasks defined. Click "Add Task" to create your first practical assessment task.
          </Alert>
        ) : (
          <div>
            {trainingForm.practicalTasks.map((task) => (
              <Accordion key={task.id}>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Box display="flex" alignItems="center" width="100%">
                    <Typography style={{ flexGrow: 1 }}>
                      {task.description.substring(0, 100)}
                      {task.description.length > 100 ? '...' : ''}
                    </Typography>
                    <Chip 
                      size="small" 
                      label={\`\${task.timeAllotted} min\`}
                      style={{ marginRight: 8 }}
                    />
                    <Chip 
                      size="small" 
                      label={\`\${task.passingThreshold}% to pass\`}
                    />
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Box width="100%">
                    <Typography variant="body1" paragraph>
                      {task.description}
                    </Typography>
                    
                    <Box mb={2}>
                      <Typography variant="subtitle2">Evaluation Criteria:</Typography>
                      <ul>
                        {task.criteria.map((criterion, index) => (
                          <li key={index}>
                            <Typography variant="body2">{criterion}</Typography>
                          </li>
                        ))}
                      </ul>
                    </Box>
                    
                    {task.equipmentNeeded && task.equipmentNeeded.length > 0 && (
                      <Box mb={2}>
                        <Typography variant="subtitle2">Equipment Needed:</Typography>
                        <Typography variant="body2">
                          {task.equipmentNeeded.join(', ')}
                        </Typography>
                      </Box>
                    )}
                    
                    <Box display="flex" justifyContent="flex-end" mt={2}>
                      <Button 
                        size="small" 
                        startIcon={<EditIcon />}
                        onClick={() => handleOpenTaskDialog(task)}
                        style={{ marginRight: 8 }}
                      >
                        Edit
                      </Button>
                      <Button 
                        size="small" 
                        startIcon={<DeleteIcon />}
                        onClick={() => handleDeleteTask(task.id)}
                      >
                        Delete
                      </Button>
                    </Box>
                  </Box>
                </AccordionDetails>
              </Accordion>
            ))}
          </div>
        )}
      </Paper>
      
      <Paper style={{ padding: 20, marginBottom: 20 }}>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
          <Typography variant="h6">Signoff Requirements</Typography>
          <Button 
            startIcon={<AddIcon />}
            onClick={() => handleOpenSignoffDialog()}
          >
            Add Signoff
          </Button>
        </Box>
        
        {!trainingForm.signoffRequirements || trainingForm.signoffRequirements.length === 0 ? (
          <Alert severity="info" style={{ marginBottom: 20 }}>
            No signoff requirements defined. Click "Add Signoff" to create a signoff requirement.
          </Alert>
        ) : (
          <div>
            {trainingForm.signoffRequirements.map((signoff, index) => (
              <Card key={index} style={{ marginBottom: 16 }}>
                <CardContent>
                  <Box display="flex" justifyContent="space-between" alignItems="center" mb={1}>
                    <Typography variant="h6">{signoff.title}</Typography>
                    <Chip 
                      size="small" 
                      label={signoff.role}
                    />
                  </Box>
                  
                  <Typography variant="body1" paragraph>
                    {signoff.description}
                  </Typography>
                  
                  {signoff.regulatoryReference && (
                    <Typography variant="body2" color="textSecondary">
                      Regulatory Reference: {signoff.regulatoryReference}
                    </Typography>
                  )}
                </CardContent>
                <CardActions>
                  <Button 
                    size="small" 
                    startIcon={<EditIcon />}
                    onClick={() => handleOpenSignoffDialog(signoff)}
                    style={{ marginRight: 8 }}
                  >
                    Edit
                  </Button>
                  <Button 
                    size="small" 
                    startIcon={<DeleteIcon />}
                    onClick={() => handleDeleteSignoff(signoff.title, signoff.role)}
                  >
                    Delete
                  </Button>
                </CardActions>
              </Card>
            ))}
          </div>
        )}
      </Paper>
      
      <Box display="flex" justifyContent="space-between" mb={4}>
        <Button variant="outlined" onClick={handleCancel}>
          Cancel
        </Button>
        
        <Button 
          variant="contained" 
          color="primary" 
          startIcon={<SaveIcon />}
          onClick={handleSave}
          disabled={saving}
        >
          {saving ? 'Saving...' : 'Save Changes'}
        </Button>
      </Box>
      
      {/* Question Dialog */}
      <Dialog open={questionDialogOpen} onClose={handleCloseQuestionDialog} maxWidth="md" fullWidth>
        <DialogTitle>
          {editingQuestion && editingQuestion.id ? 'Edit Question' : 'Add Question'}
        </DialogTitle>
        <DialogContent>
          <Grid container spacing={3}>
            <Grid item xs={12} sm={8}>
              <TextField
                fullWidth
                label="Question"
                name="question"
                value={editingQuestion?.question || ''}
                onChange={handleQuestionInputChange}
                variant="outlined"
                margin="normal"
                multiline
                rows={3}
                required
              />
            </Grid>
            
            <Grid item xs={12} sm={4}>
              <FormControl variant="outlined" fullWidth margin="normal">
                <InputLabel>Question Type</InputLabel>
                <Select
                  name="type"
                  value={editingQuestion?.type || 'multiple-choice'}
                  onChange={handleQuestionInputChange}
                  label="Question Type"
                >
                  <MenuItem value="multiple-choice">Multiple Choice</MenuItem>
                  <MenuItem value="true-false">True/False</MenuItem>
                  <MenuItem value="short-answer">Short Answer</MenuItem>
                  <MenuItem value="fill-in-blank">Fill in the Blank</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12} sm={4}>
              <TextField
                fullWidth
                label="Points"
                name="points"
                type="number"
                value={editingQuestion?.points || 1}
                onChange={handleQuestionInputChange}
                variant="outlined"
                margin="normal"
                inputProps={{ min: 1, max: 10 }}
                required
              />
            </Grid>
            
            {/* Options for multiple-choice questions */}
            {editingQuestion && editingQuestion.type === 'multiple-choice' && (
              <Grid item xs={12}>
                <Box mb={2}>
                  <Typography variant="subtitle1">Options:</Typography>
                  
                  {editingQuestion.options.map((option, index) => (
                    <Box key={index} display="flex" alignItems="center" mb={1}>
                      <Radio
                        checked={option === editingQuestion.correctAnswer}
                        onChange={() => handleCorrectAnswerChange(option)}
                        name="correct-answer"
                      />
                      <TextField
                        fullWidth
                        label={\`Option \${index + 1}\`}
                        value={option}
                        onChange={(e) => handleOptionChange(index, e.target.value)}
                        variant="outlined"
                        margin="dense"
                      />
                      <IconButton 
                        onClick={() => handleRemoveOption(index)}
                        disabled={editingQuestion.options.length <= 2}
                      >
                        <DeleteIcon />
                      </IconButton>
                    </Box>
                  ))}
                  
                  <Button 
                    startIcon={<AddIcon />}
                    onClick={handleAddOption}
                    disabled={editingQuestion.options.length >= 6}
                  >
                    Add Option
                  </Button>
                </Box>
              </Grid>
            )}
            
            {/* Correct answer for true-false questions */}
            {editingQuestion && editingQuestion.type === 'true-false' && (
              <Grid item xs={12}>
                <FormControl component="fieldset" margin="normal">
                  <FormLabel component="legend">Correct Answer</FormLabel>
                  <RadioGroup
                    name="correctAnswer"
                    value={editingQuestion.correctAnswer}
                    onChange={(e) => handleCorrectAnswerChange(e.target.value)}
                  >
                    <FormControlLabel value="True" control={<Radio />} label="True" />
                    <FormControlLabel value="False" control={<Radio />} label="False" />
                  </RadioGroup>
                </FormControl>
              </Grid>
            )}
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Explanation (Optional)"
                name="explanation"
                value={editingQuestion?.explanation || ''}
                onChange={handleQuestionInputChange}
                variant="outlined"
                margin="normal"
                multiline
                rows={2}
              />
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseQuestionDialog} color="default">
            Cancel
          </Button>
          <Button 
            onClick={handleSaveQuestion} 
            color="primary" 
            variant="contained"
            disabled={
              !editingQuestion?.question || 
              (editingQuestion?.type === 'multiple-choice' && 
               (!editingQuestion?.options || !editingQuestion?.correctAnswer))
            }
          >
            Save
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Task Dialog */}
      <Dialog open={taskDialogOpen} onClose={handleCloseTaskDialog} maxWidth="md" fullWidth>
        <DialogTitle>
          {editingTask && editingTask.id ? 'Edit Task' : 'Add Task'}
        </DialogTitle>
        <DialogContent>
          <Grid container spacing={3}>
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Task Description"
                name="description"
                value={editingTask?.description || ''}
                onChange={handleTaskInputChange}
                variant="outlined"
                margin="normal"
                multiline
                rows={3}
                required
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Passing Threshold (%)"
                name="passingThreshold"
                type="number"
                value={editingTask?.passingThreshold || 70}
                onChange={handleTaskInputChange}
                variant="outlined"
                margin="normal"
                inputProps={{ min: 50, max: 100 }}
                required
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Time Allotted (minutes)"
                name="timeAllotted"
                type="number"
                value={editingTask?.timeAllotted || 15}
                onChange={handleTaskInputChange}
                variant="outlined"
                margin="normal"
                inputProps={{ min: 5, max: 120 }}
                required
              />
            </Grid>
            
            <Grid item xs={12}>
              <Box mb={2}>
                <Typography variant="subtitle1">Evaluation Criteria:</Typography>
                
                {editingTask && editingTask.criteria.map((criterion, index) => (
                  <Box key={index} display="flex" alignItems="center" mb={1}>
                    <TextField
                      fullWidth
                      label={\`Criterion \${index + 1}\`}
                      value={criterion}
                      onChange={(e) => handleCriteriaChange(index, e.target.value)}
                      variant="outlined"
                      margin="dense"
                    />
                    <IconButton 
                      onClick={() => handleRemoveCriteria(index)}
                      disabled={editingTask.criteria.length <= 1}
                    >
                      <DeleteIcon />
                    </IconButton>
                  </Box>
                ))}
                
                <Button 
                  startIcon={<AddIcon />}
                  onClick={handleAddCriteria}
                >
                  Add Criterion
                </Button>
              </Box>
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Equipment Needed (comma separated)"
                name="equipmentNeeded"
                value={(editingTask?.equipmentNeeded || []).join(', ')}
                onChange={handleEquipmentChange}
                variant="outlined"
                margin="normal"
              />
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseTaskDialog} color="default">
            Cancel
          </Button>
          <Button 
            onClick={handleSaveTask} 
            color="primary" 
            variant="contained"
            disabled={
              !editingTask?.description || 
              !editingTask?.criteria || 
              !editingTask?.criteria.some(c => c.trim())
            }
          >
            Save
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Signoff Dialog */}
      <Dialog open={signoffDialogOpen} onClose={handleCloseSignoffDialog} maxWidth="md" fullWidth>
        <DialogTitle>
          {editingSignoff ? 'Edit Signoff Requirement' : 'Add Signoff Requirement'}
        </DialogTitle>
        <DialogContent>
          <Grid container spacing={3}>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Title"
                name="title"
                value={editingSignoff?.title || ''}
                onChange={handleSignoffInputChange}
                variant="outlined"
                margin="normal"
                required
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <FormControl variant="outlined" fullWidth margin="normal">
                <InputLabel>Role</InputLabel>
                <Select
                  name="role"
                  value={editingSignoff?.role || 'Instructor'}
                  onChange={handleSignoffInputChange}
                  label="Role"
                >
                  <MenuItem value="Instructor">Instructor</MenuItem>
                  <MenuItem value="Supervisor">Supervisor</MenuItem>
                  <MenuItem value="Manager">Manager</MenuItem>
                  <MenuItem value="Examiner">Examiner</MenuItem>
                  <MenuItem value="Quality Assurance">Quality Assurance</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Description"
                name="description"
                value={editingSignoff?.description || ''}
                onChange={handleSignoffInputChange}
                variant="outlined"
                margin="normal"
                multiline
                rows={3}
                required
              />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Regulatory Reference (Optional)"
                name="regulatoryReference"
                value={editingSignoff?.regulatoryReference || ''}
                onChange={handleSignoffInputChange}
                variant="outlined"
                margin="normal"
              />
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseSignoffDialog} color="default">
            Cancel
          </Button>
          <Button 
            onClick={handleSaveSignoff} 
            color="primary" 
            variant="contained"
            disabled={!editingSignoff?.title || !editingSignoff?.description}
          >
            Save
          </Button>
        </DialogActions>
      </Dialog>
    </div>
  );
}

export default TrainingFormEditor;
`;
}

/**
 * package.json configuration file
 */
const packageJson = () => {
  return `
{
  "name": "aviation-training-document-system",
  "version": "1.0.0",
  "description": "A comprehensive system for managing aviation training documents, extracting content, and generating training materials",
  "main": "index.js",
  "scripts": {
    "start": "concurrently \"npm run server\" \"npm run client\"",
    "server": "nodemon index.js",
    "client": "cd client && npm start",
    "build": "cd client && npm run build",
    "install-all": "npm install && cd client && npm install",
    "test": "jest"
  },
  "keywords": [
    "aviation",
    "training",
    "document",
    "management",
    "compliance"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "cors": "^2.8.5",
    "docx": "^7.3.0",
    "express": "^4.17.1",
    "file-saver": "^2.0.5",
    "mammoth": "^1.4.19",
    "mongoose": "^6.0.12",
    "multer": "^1.4.3",
    "pdfjs-dist": "^2.10.377",
    "uuid": "^8.3.2"
  },
  "devDependencies": {
    "concurrently": "^6.3.0",
    "jest": "^27.3.1",
    "nodemon": "^2.0.14"
  }
}
`;
}

/**
 * Client-side package.json configuration
 */
const clientPackageJson = () => {
  return `
{
  "name": "aviation-training-document-system-client",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "@material-ui/core": "^4.12.3",
    "@material-ui/icons": "^4.11.2",
    "@material-ui/lab": "^4.0.0-alpha.60",
    "axios": "^0.24.0",
    "date-fns": "^2.25.0",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-router-dom": "^5.3.0",
    "react-scripts": "4.0.3"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "proxy": "http://localhost:5000"
}
`;
}

/**
 * README.md file with implementation details and usage instructions
 */
const readmeMd = () => {
  return `
# Aviation Training Document Management System

A comprehensive system for aviation training platforms that processes uploaded manuals, extracts content, identifies compliance procedures, and generates training materials.

## Features

- Document processing for PDF and DOCX aviation training manuals
- Automatic extraction of document structure, key terms, and compliance procedures
- Generation of instructor and student session plans based on document content
- Creation of assessment forms with multiple question types
- Practical skills assessment form generation
- Compliance verification and regulatory reference tracking
- Customizable training materials export (DOCX)

## System Architecture

### Backend Components

- **DocumentProcessor**: Extracts structured content from uploaded documents
- **SessionPlanGenerator**: Creates training session plans from extracted content
- **TrainingFormGenerator**: Produces assessment forms and practical evaluations
- **RESTful API**: Provides endpoints for document management and material generation
- **MongoDB**: Stores processed documents and generated materials

### Frontend Components

- **Document Upload**: File selection with progress tracking
- **Document Viewer**: Organized display of extracted content
- **Session Plan Editor**: Customizable training session creation
- **Training Form Editor**: Assessment form modification
- **Material Export**: Export to standard document formats

## Getting Started

### Prerequisites

- Node.js (v14+)
- MongoDB (v4+)
- npm

### Installation

1. Clone the repository
   \`\`\`bash
   git clone https://github.com/yourusername/aviation-training-system.git
   cd aviation-training-system
   \`\`\`

2. Install dependencies
   \`\`\`bash
   npm run install-all
   \`\`\`

3. Configure MongoDB
   
   Create a file named \`.env\` in the root directory with the following content:
   \`\`\`
   MONGODB_URI=mongodb://localhost:27017/aviation-training
   \`\`\`

4. Start the application
   \`\`\`bash
   npm start
   \`\`\`

5. Access the application at http://localhost:3000

## Usage

### Document Upload and Processing

1. From the dashboard, click "Upload New Document"
2. Select a PDF or DOCX aviation training document
3. Configure processing options (defaults are recommended for most cases)
4. Upload and wait for processing to complete

### Session Plan Generation

1. View the processed document and click "Generate Session Plans"
2. Customize the generated session plans as needed
3. Export the session plans in DOCX format

### Training Form Creation

1. From the document view, click "Generate Training Forms"
2. Edit the assessment questions, practical tasks, and signoff requirements
3. Export the finalized forms

## API Reference

The system provides a RESTful API with the following main endpoints:

- `/api/documents` - Document management
- `/api/documents/:id/session-plans` - Session plan generation
- `/api/documents/:id/training-forms` - Training form generation
- `/api/session-plans/:id` - Session plan operations
- `/api/training-forms/:id` - Training form operations

For detailed API documentation, see the [API Reference](docs/api.md).

## Contributing

Contributions are welcome! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for details.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
`;
}

/**
 * Implementation structure diagram
 */
const structureDiagram = () => {
  return `
project-root/
â”œâ”€â”€ client/                     # Frontend React application
â”‚   â”œâ”€â”€ public/                  # Static files
â”‚   â””â”€â”€ src/                     # React source files
â”‚       â”œâ”€â”€ components/          # React components
â”‚       â”œâ”€â”€ App.jsx              # Main application component
â”‚       â””â”€â”€ index.js             # Application entry point
â”œâ”€â”€ models/                     # MongoDB models
â”‚   â”œâ”€â”€ Document.js              # Document model
â”‚   â”œâ”€â”€ SessionPlan.js           # Session plan model
â”‚   â””â”€â”€ TrainingForm.js          # Training form model
â”œâ”€â”€ routes/                     # API routes
â”‚   â”œâ”€â”€ documents.js             # Document routes
â”‚   â”œâ”€â”€ sessionPlans.js          # Session plan routes
â”‚   â””â”€â”€ trainingForms.js         # Training form routes
â”œâ”€â”€ services/                   # Business logic services
â”‚   â”œâ”€â”€ DocumentProcessor.js     # Document processing service
â”‚   â”œâ”€â”€ SessionPlanGenerator.js  # Session plan generation service
â”‚   â””â”€â”€ TrainingFormGenerator.js # Training form generation service
â”œâ”€â”€ uploads/                    # Uploaded document storage
â”œâ”€â”€ .env                        # Environment variables
â”œâ”€â”€ .gitignore                  # Git ignore file
â”œâ”€â”€ index.js                    # Server entry point
â”œâ”€â”€ package.json                # Project dependencies
â””â”€â”€ README.md                   # Project documentation
`;
}

// =====================================================================
// IMPLEMENTATION CONCLUSION
// =====================================================================

/**
 * This completes the comprehensive implementation of the Aviation Training 
 * Document Management System. The system now includes:
 * 
 * 1. A robust backend system for processing aviation training documents
 *    - Document text extraction from PDF and DOCX files
 *    - Content analysis and structure identification
 *    - Compliance procedure recognition
 *    - Key term extraction
 *    - MongoDB persistence
 * 
 * 2. Session plan generation
 *    - Automatic creation of instructor and student plans
 *    - Intelligent content organization and timing
 *    - Prioritization of safety-critical content
 *    - Editable activities, materials, and assessments
 * 
 * 3. Training form generation
 *    - Knowledge assessment questions
 *    - Practical task evaluations
 *    - Compliance verification and signoffs
 *    - Customizable export options
 * 
 * 4. A complete React frontend
 *    - Document upload and processing
 *    - Content visualization and organization
 *    - Session plan and training form editors
 *    - Material export capabilities
 * 
 * This system provides a comprehensive solution for aviation training 
 * organizations to efficiently convert existing training documentation 
 * into structured training materials, with special attention to compliance
 * and safety requirements that are critical in the aviation industry.
 */